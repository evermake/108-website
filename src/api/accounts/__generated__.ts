/**
 * Generated by orval v6.29.1 üç∫
 * Do not edit manually.
 * InNoHassle Accounts API
 *
### About this project

This is the API for Accounts project in InNoHassle ecosystem developed by one-zero-eight community.

Backend is developed using FastAPI framework on Python.

Note: API is unstable. Endpoints and models may change in the future.

Useful links:
- [Frontend source code](https://github.com/one-zero-eight/InNoHassle-Website)
- [Website](https://innohassle.ru/)

 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery } from '@tanstack/vue-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationReturnType,
  UseQueryOptions,
  UseQueryReturnType,
} from '@tanstack/vue-query'
import { computed, unref } from 'vue'
import type { MaybeRef } from 'vue'
import { axiosQuery } from './axios'
import { queryKeyMutator } from './query'

export interface LogoutParams {
  redirect_uri: string
}

export interface TokensGenerateSportTokenParams {
  telegram_id?: number | null
  innohassle_id?: string | null
  email?: string | null
}

export interface TokensGenerateServiceTokenParams {
  /**
   * Some string that will be in `sub` field of JWT token. Actually, it may be anything.
   */
  sub: string
  /**
   * List of scopes that will be in `scope` field of JWT token. Default is ['users']
   */
  scopes?: AvailableScopes[]
  /**
   * Generate token only for current user - other users will be marked as not existing in the system
   */
  only_for_me?: boolean
}

export interface TokensGenerateTokenParams {
  sub: string
  /**
   * Space delimited list of scopes
   */
  scope?: string | null
}

export interface ProvidersInnopolisLoginOrRegisterParams {
  redirect_uri: string
  prompt?: 'none' | null
}

export type ValidationErrorLocItem = string | number

export interface ValidationError {
  loc: ValidationErrorLocItem[]
  msg: string
  type: string
}

export type UserInfoFromSSOName = string | null

export type UserInfoFromSSOIssuedAt = string | null

export interface UserInfoFromSSO {
  email: string
  issued_at?: UserInfoFromSSOIssuedAt
  name?: UserInfoFromSSOName
}

export type UserTelegram = TelegramWidgetData | null

export type UserInnopolisSso = UserInfoFromSSO | null

export interface User {
  /** MongoDB document ObjectID */
  id: string
  innohassle_admin: boolean
  innopolis_sso: UserInnopolisSso
  telegram: UserTelegram
}

export interface TokenData {
  access_token: string
}

export type TelegramWidgetDataUsername = string | null

export type TelegramWidgetDataPhotoUrl = string | null

export type TelegramWidgetDataLastName = string | null

export interface TelegramWidgetData {
  auth_date: number
  first_name: string
  hash: string
  id: number
  last_name?: TelegramWidgetDataLastName
  photo_url?: TelegramWidgetDataPhotoUrl
  username?: TelegramWidgetDataUsername
}

export interface TelegramLoginResponse {
  need_to_connect: boolean
}

export interface HTTPValidationError {
  detail?: ValidationError[]
}

export type AvailableScopes =
  (typeof AvailableScopes)[keyof typeof AvailableScopes]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AvailableScopes = {
  users: 'users',
  sport: 'sport',
} as const

type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1]

/**
 * @summary Innopolis Login Or Register
 */
export function providersInnopolisLoginOrRegister(
  params: MaybeRef<ProvidersInnopolisLoginOrRegisterParams>,
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) {
  params = unref(params)

  return axiosQuery<unknown>(
    {
      url: `/providers/innopolis/login`,
      method: 'GET',
      params: unref(params),
      signal,
    },
    options,
  )
}

export function useProvidersInnopolisLoginOrRegisterQueryOptions<
  TData = Awaited<ReturnType<typeof providersInnopolisLoginOrRegister>>,
  TError = HTTPValidationError,
>(
  params: MaybeRef<ProvidersInnopolisLoginOrRegisterParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof providersInnopolisLoginOrRegister>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosQuery>
  },
) {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryKeyMutator(
    { params },
    { url: `/providers/innopolis/login`, queryOptions },
  )

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof providersInnopolisLoginOrRegister>>
  > = ({ signal }) =>
    providersInnopolisLoginOrRegister(params, requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof providersInnopolisLoginOrRegister>>,
    TError,
    TData
  >
}

export type ProvidersInnopolisLoginOrRegisterQueryResult = NonNullable<
  Awaited<ReturnType<typeof providersInnopolisLoginOrRegister>>
>
export type ProvidersInnopolisLoginOrRegisterQueryError = HTTPValidationError

/**
 * @summary Innopolis Login Or Register
 */
export function useProvidersInnopolisLoginOrRegister<
  TData = Awaited<ReturnType<typeof providersInnopolisLoginOrRegister>>,
  TError = HTTPValidationError,
>(
  params: MaybeRef<ProvidersInnopolisLoginOrRegisterParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof providersInnopolisLoginOrRegister>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosQuery>
  },
): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = useProvidersInnopolisLoginOrRegisterQueryOptions(
    params,
    options,
  )

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = unref(queryOptions).queryKey as QueryKey

  return query
}

/**
 * @summary Innopolis Callback
 */
export function providersInnopolisCallback(
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) {
  return axiosQuery<unknown>(
    { url: `/providers/innopolis/callback`, method: 'GET', signal },
    options,
  )
}

export function useProvidersInnopolisCallbackQueryOptions<
  TData = Awaited<ReturnType<typeof providersInnopolisCallback>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof providersInnopolisCallback>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosQuery>
}) {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryKeyMutator(
    {},
    { url: `/providers/innopolis/callback`, queryOptions },
  )

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof providersInnopolisCallback>>
  > = ({ signal }) => providersInnopolisCallback(requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof providersInnopolisCallback>>,
    TError,
    TData
  >
}

export type ProvidersInnopolisCallbackQueryResult = NonNullable<
  Awaited<ReturnType<typeof providersInnopolisCallback>>
>
export type ProvidersInnopolisCallbackQueryError = unknown

/**
 * @summary Innopolis Callback
 */
export function useProvidersInnopolisCallback<
  TData = Awaited<ReturnType<typeof providersInnopolisCallback>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof providersInnopolisCallback>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = useProvidersInnopolisCallbackQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = unref(queryOptions).queryKey as QueryKey

  return query
}

/**
 * @summary Telegram Connect
 */
export function providersTelegramConnect(
  telegramWidgetData: MaybeRef<TelegramWidgetData>,
  options?: SecondParameter<typeof axiosQuery>,
) {
  telegramWidgetData = unref(telegramWidgetData)

  return axiosQuery<unknown>(
    {
      url: `/providers/telegram/connect`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: telegramWidgetData,
    },
    options,
  )
}

export function getProvidersTelegramConnectMutationOptions<
  TError = void | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof providersTelegramConnect>>,
    TError,
    { data: TelegramWidgetData },
    TContext
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseMutationOptions<
    Awaited<ReturnType<typeof providersTelegramConnect>>,
    TError,
    { data: TelegramWidgetData },
    TContext
  > {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof providersTelegramConnect>>,
    { data: TelegramWidgetData }
  > = (props) => {
    const { data } = props ?? {}

    return providersTelegramConnect(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ProvidersTelegramConnectMutationResult = NonNullable<
  Awaited<ReturnType<typeof providersTelegramConnect>>
>
export type ProvidersTelegramConnectMutationBody = TelegramWidgetData
export type ProvidersTelegramConnectMutationError = void | HTTPValidationError

/**
 * @summary Telegram Connect
 */
export function useProvidersTelegramConnect<
  TError = void | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof providersTelegramConnect>>,
    TError,
    { data: TelegramWidgetData },
    TContext
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseMutationReturnType<
    Awaited<ReturnType<typeof providersTelegramConnect>>,
    TError,
    { data: TelegramWidgetData },
    TContext
  > {
  const mutationOptions = getProvidersTelegramConnectMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Telegram Login
 */
export function providersTelegramLogin(
  telegramWidgetData: MaybeRef<TelegramWidgetData>,
  options?: SecondParameter<typeof axiosQuery>,
) {
  telegramWidgetData = unref(telegramWidgetData)

  return axiosQuery<TelegramLoginResponse>(
    {
      url: `/providers/telegram/login`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: telegramWidgetData,
    },
    options,
  )
}

export function getProvidersTelegramLoginMutationOptions<
  TError = void | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof providersTelegramLogin>>,
    TError,
    { data: TelegramWidgetData },
    TContext
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseMutationOptions<
    Awaited<ReturnType<typeof providersTelegramLogin>>,
    TError,
    { data: TelegramWidgetData },
    TContext
  > {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof providersTelegramLogin>>,
    { data: TelegramWidgetData }
  > = (props) => {
    const { data } = props ?? {}

    return providersTelegramLogin(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ProvidersTelegramLoginMutationResult = NonNullable<
  Awaited<ReturnType<typeof providersTelegramLogin>>
>
export type ProvidersTelegramLoginMutationBody = TelegramWidgetData
export type ProvidersTelegramLoginMutationError = void | HTTPValidationError

/**
 * @summary Telegram Login
 */
export function useProvidersTelegramLogin<
  TError = void | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof providersTelegramLogin>>,
    TError,
    { data: TelegramWidgetData },
    TContext
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseMutationReturnType<
    Awaited<ReturnType<typeof providersTelegramLogin>>,
    TError,
    { data: TelegramWidgetData },
    TContext
  > {
  const mutationOptions = getProvidersTelegramLoginMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Get current user info if authenticated
 * @summary Get Me
 */
export function usersGetMe(
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) {
  return axiosQuery<User>({ url: `/users/me`, method: 'GET', signal }, options)
}

export function useUsersGetMeQueryOptions<
  TData = Awaited<ReturnType<typeof usersGetMe>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof usersGetMe>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosQuery>
}) {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryKeyMutator({}, { url: `/users/me`, queryOptions })

  const queryFn: QueryFunction<Awaited<ReturnType<typeof usersGetMe>>> = ({
    signal,
  }) => usersGetMe(requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof usersGetMe>>,
    TError,
    TData
  >
}

export type UsersGetMeQueryResult = NonNullable<
  Awaited<ReturnType<typeof usersGetMe>>
>
export type UsersGetMeQueryError = void

/**
 * @summary Get Me
 */
export function useUsersGetMe<
  TData = Awaited<ReturnType<typeof usersGetMe>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof usersGetMe>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = useUsersGetMeQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = unref(queryOptions).queryKey as QueryKey

  return query
}

/**
 * Get user by telegram id
 * @summary Get User By Telegram Id
 */
export function usersGetUserByTelegramId(
  telegramId: MaybeRef<number>,
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) {
  telegramId = unref(telegramId)

  return axiosQuery<User>(
    { url: `/users/by-telegram-id/${telegramId}`, method: 'GET', signal },
    options,
  )
}

export function useUsersGetUserByTelegramIdQueryOptions<
  TData = Awaited<ReturnType<typeof usersGetUserByTelegramId>>,
  TError = void | HTTPValidationError,
>(
  telegramId: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof usersGetUserByTelegramId>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosQuery>
  },
) {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryKeyMutator(
    { telegramId },
    { url: `/users/by-telegram-id/${telegramId}`, queryOptions },
  )

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof usersGetUserByTelegramId>>
  > = ({ signal }) =>
    usersGetUserByTelegramId(telegramId, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(telegramId)),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof usersGetUserByTelegramId>>,
    TError,
    TData
  >
}

export type UsersGetUserByTelegramIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof usersGetUserByTelegramId>>
>
export type UsersGetUserByTelegramIdQueryError = void | HTTPValidationError

/**
 * @summary Get User By Telegram Id
 */
export function useUsersGetUserByTelegramId<
  TData = Awaited<ReturnType<typeof usersGetUserByTelegramId>>,
  TError = void | HTTPValidationError,
>(
  telegramId: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof usersGetUserByTelegramId>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosQuery>
  },
): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = useUsersGetUserByTelegramIdQueryOptions(
    telegramId,
    options,
  )

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = unref(queryOptions).queryKey as QueryKey

  return query
}

/**
 * Get user by id
 * @summary Get User By Id
 */
export function usersGetUserById(
  userId: MaybeRef<string>,
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) {
  userId = unref(userId)

  return axiosQuery<User>(
    { url: `/users/by-id/${userId}`, method: 'GET', signal },
    options,
  )
}

export function useUsersGetUserByIdQueryOptions<
  TData = Awaited<ReturnType<typeof usersGetUserById>>,
  TError = void | HTTPValidationError,
>(
  userId: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof usersGetUserById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosQuery>
  },
) {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryKeyMutator(
    { userId },
    { url: `/users/by-id/${userId}`, queryOptions },
  )

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof usersGetUserById>>
  > = ({ signal }) => usersGetUserById(userId, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(userId)),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof usersGetUserById>>,
    TError,
    TData
  >
}

export type UsersGetUserByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof usersGetUserById>>
>
export type UsersGetUserByIdQueryError = void | HTTPValidationError

/**
 * @summary Get User By Id
 */
export function useUsersGetUserById<
  TData = Awaited<ReturnType<typeof usersGetUserById>>,
  TError = void | HTTPValidationError,
>(
  userId: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof usersGetUserById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosQuery>
  },
): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = useUsersGetUserByIdQueryOptions(userId, options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = unref(queryOptions).queryKey as QueryKey

  return query
}

/**
 * Get user by email
 * @summary Get User By Innomail
 */
export function usersGetUserByInnomail(
  email: MaybeRef<string>,
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) {
  email = unref(email)

  return axiosQuery<User>(
    { url: `/users/by-innomail/${email}`, method: 'GET', signal },
    options,
  )
}

export function useUsersGetUserByInnomailQueryOptions<
  TData = Awaited<ReturnType<typeof usersGetUserByInnomail>>,
  TError = void | HTTPValidationError,
>(
  email: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof usersGetUserByInnomail>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosQuery>
  },
) {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryKeyMutator(
    { email },
    { url: `/users/by-innomail/${email}`, queryOptions },
  )

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof usersGetUserByInnomail>>
  > = ({ signal }) => usersGetUserByInnomail(email, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(email)),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof usersGetUserByInnomail>>,
    TError,
    TData
  >
}

export type UsersGetUserByInnomailQueryResult = NonNullable<
  Awaited<ReturnType<typeof usersGetUserByInnomail>>
>
export type UsersGetUserByInnomailQueryError = void | HTTPValidationError

/**
 * @summary Get User By Innomail
 */
export function useUsersGetUserByInnomail<
  TData = Awaited<ReturnType<typeof usersGetUserByInnomail>>,
  TError = void | HTTPValidationError,
>(
  email: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof usersGetUserByInnomail>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosQuery>
  },
): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = useUsersGetUserByInnomailQueryOptions(email, options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = unref(queryOptions).queryKey as QueryKey

  return query
}

/**
 * Get jwks for jwt
 * @summary Get Jwks
 */
export function tokensGetJwks(
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) {
  return axiosQuery<unknown>(
    { url: `/.well-known/jwks.json`, method: 'GET', signal },
    options,
  )
}

export function useTokensGetJwksQueryOptions<
  TData = Awaited<ReturnType<typeof tokensGetJwks>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof tokensGetJwks>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosQuery>
}) {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryKeyMutator(
    {},
    { url: `/.well-known/jwks.json`, queryOptions },
  )

  const queryFn: QueryFunction<Awaited<ReturnType<typeof tokensGetJwks>>> = ({
    signal,
  }) => tokensGetJwks(requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof tokensGetJwks>>,
    TError,
    TData
  >
}

export type TokensGetJwksQueryResult = NonNullable<
  Awaited<ReturnType<typeof tokensGetJwks>>
>
export type TokensGetJwksQueryError = unknown

/**
 * @summary Get Jwks
 */
export function useTokensGetJwks<
  TData = Awaited<ReturnType<typeof tokensGetJwks>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof tokensGetJwks>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = useTokensGetJwksQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = unref(queryOptions).queryKey as QueryKey

  return query
}

/**
 * Generate access token for current user with user id in `uid` field
 * @summary Generate My Token
 */
export function tokensGenerateMyToken(
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) {
  return axiosQuery<TokenData>(
    { url: `/tokens/generate-my-token`, method: 'GET', signal },
    options,
  )
}

export function useTokensGenerateMyTokenQueryOptions<
  TData = Awaited<ReturnType<typeof tokensGenerateMyToken>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof tokensGenerateMyToken>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosQuery>
}) {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryKeyMutator(
    {},
    { url: `/tokens/generate-my-token`, queryOptions },
  )

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof tokensGenerateMyToken>>
  > = ({ signal }) => tokensGenerateMyToken(requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof tokensGenerateMyToken>>,
    TError,
    TData
  >
}

export type TokensGenerateMyTokenQueryResult = NonNullable<
  Awaited<ReturnType<typeof tokensGenerateMyToken>>
>
export type TokensGenerateMyTokenQueryError = void

/**
 * @summary Generate My Token
 */
export function useTokensGenerateMyToken<
  TData = Awaited<ReturnType<typeof tokensGenerateMyToken>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof tokensGenerateMyToken>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = useTokensGenerateMyTokenQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = unref(queryOptions).queryKey as QueryKey

  return query
}

/**
 * Generate access token with some sub in `sub` field
 * @summary Generate Token
 */
export function tokensGenerateToken(
  params: MaybeRef<TokensGenerateTokenParams>,
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) {
  params = unref(params)

  return axiosQuery<TokenData>(
    {
      url: `/tokens/generate-access-token`,
      method: 'GET',
      params: unref(params),
      signal,
    },
    options,
  )
}

export function useTokensGenerateTokenQueryOptions<
  TData = Awaited<ReturnType<typeof tokensGenerateToken>>,
  TError = void | HTTPValidationError,
>(
  params: MaybeRef<TokensGenerateTokenParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof tokensGenerateToken>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosQuery>
  },
) {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryKeyMutator(
    { params },
    { url: `/tokens/generate-access-token`, queryOptions },
  )

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof tokensGenerateToken>>
  > = ({ signal }) => tokensGenerateToken(params, requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof tokensGenerateToken>>,
    TError,
    TData
  >
}

export type TokensGenerateTokenQueryResult = NonNullable<
  Awaited<ReturnType<typeof tokensGenerateToken>>
>
export type TokensGenerateTokenQueryError = void | HTTPValidationError

/**
 * @summary Generate Token
 */
export function useTokensGenerateToken<
  TData = Awaited<ReturnType<typeof tokensGenerateToken>>,
  TError = void | HTTPValidationError,
>(
  params: MaybeRef<TokensGenerateTokenParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof tokensGenerateToken>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosQuery>
  },
): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = useTokensGenerateTokenQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = unref(queryOptions).queryKey as QueryKey

  return query
}

/**
 * Generate access token for access users-related endpoints (/users/*).
 * @summary Generate Service Token
 */
export function tokensGenerateServiceToken(
  params: MaybeRef<TokensGenerateServiceTokenParams>,
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) {
  params = unref(params)

  return axiosQuery<TokenData>(
    {
      url: `/tokens/generate-service-token`,
      method: 'GET',
      params: unref(params),
      signal,
    },
    options,
  )
}

export function useTokensGenerateServiceTokenQueryOptions<
  TData = Awaited<ReturnType<typeof tokensGenerateServiceToken>>,
  TError = void | HTTPValidationError,
>(
  params: MaybeRef<TokensGenerateServiceTokenParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof tokensGenerateServiceToken>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosQuery>
  },
) {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryKeyMutator(
    { params },
    { url: `/tokens/generate-service-token`, queryOptions },
  )

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof tokensGenerateServiceToken>>
  > = ({ signal }) =>
    tokensGenerateServiceToken(params, requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof tokensGenerateServiceToken>>,
    TError,
    TData
  >
}

export type TokensGenerateServiceTokenQueryResult = NonNullable<
  Awaited<ReturnType<typeof tokensGenerateServiceToken>>
>
export type TokensGenerateServiceTokenQueryError = void | HTTPValidationError

/**
 * @summary Generate Service Token
 */
export function useTokensGenerateServiceToken<
  TData = Awaited<ReturnType<typeof tokensGenerateServiceToken>>,
  TError = void | HTTPValidationError,
>(
  params: MaybeRef<TokensGenerateServiceTokenParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof tokensGenerateServiceToken>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosQuery>
  },
): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = useTokensGenerateServiceTokenQueryOptions(
    params,
    options,
  )

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = unref(queryOptions).queryKey as QueryKey

  return query
}

/**
 * Generate access token for access https://sport.innopolis.university/api/swagger/
 * @summary Generate Sport Token
 */
export function tokensGenerateSportToken(
  params?: MaybeRef<TokensGenerateSportTokenParams>,
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) {
  params = unref(params)

  return axiosQuery<TokenData>(
    {
      url: `/tokens/generate-sport-token`,
      method: 'GET',
      params: unref(params),
      signal,
    },
    options,
  )
}

export function useTokensGenerateSportTokenQueryOptions<
  TData = Awaited<ReturnType<typeof tokensGenerateSportToken>>,
  TError = void | HTTPValidationError,
>(
  params?: MaybeRef<TokensGenerateSportTokenParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof tokensGenerateSportToken>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosQuery>
  },
) {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryKeyMutator(
    { params },
    { url: `/tokens/generate-sport-token`, queryOptions },
  )

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof tokensGenerateSportToken>>
  > = ({ signal }) => tokensGenerateSportToken(params, requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof tokensGenerateSportToken>>,
    TError,
    TData
  >
}

export type TokensGenerateSportTokenQueryResult = NonNullable<
  Awaited<ReturnType<typeof tokensGenerateSportToken>>
>
export type TokensGenerateSportTokenQueryError = void | HTTPValidationError

/**
 * @summary Generate Sport Token
 */
export function useTokensGenerateSportToken<
  TData = Awaited<ReturnType<typeof tokensGenerateSportToken>>,
  TError = void | HTTPValidationError,
>(
  params?: MaybeRef<TokensGenerateSportTokenParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof tokensGenerateSportToken>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosQuery>
  },
): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = useTokensGenerateSportTokenQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = unref(queryOptions).queryKey as QueryKey

  return query
}

/**
 * @summary Logout
 */
export function logout(
  params: MaybeRef<LogoutParams>,
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) {
  params = unref(params)

  return axiosQuery<unknown>(
    { url: `/logout`, method: 'GET', params: unref(params), signal },
    options,
  )
}

export function useLogoutQueryOptions<
  TData = Awaited<ReturnType<typeof logout>>,
  TError = void | HTTPValidationError,
>(
  params: MaybeRef<LogoutParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logout>>, TError, TData>
    >
    request?: SecondParameter<typeof axiosQuery>
  },
) {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryKeyMutator(
    { params },
    { url: `/logout`, queryOptions },
  )

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logout>>> = ({
    signal,
  }) => logout(params, requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof logout>>,
    TError,
    TData
  >
}

export type LogoutQueryResult = NonNullable<Awaited<ReturnType<typeof logout>>>
export type LogoutQueryError = void | HTTPValidationError

/**
 * @summary Logout
 */
export function useLogout<
  TData = Awaited<ReturnType<typeof logout>>,
  TError = void | HTTPValidationError,
>(
  params: MaybeRef<LogoutParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof logout>>, TError, TData>
    >
    request?: SecondParameter<typeof axiosQuery>
  },
): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = useLogoutQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = unref(queryOptions).queryKey as QueryKey

  return query
}
