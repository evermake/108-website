/**
 * Generated by orval v6.29.1 üç∫
 * Do not edit manually.
 * InNoHassle-Search
 *
### About this project

 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery } from "@tanstack/vue-query";
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationReturnType,
  UseQueryOptions,
  UseQueryReturnType,
} from "@tanstack/vue-query";
import { unref } from "vue";
import type { MaybeRef } from "vue";
import { axiosQuery } from "./axios";
import { queryKeyMutator } from "./query";

export interface MoodleGetMoodleFiles200Item {
  [key: string]: any;
}

export interface MoodlePreviewMoodleParams {
  course_id: number;
  module_id: number;
  filename: string;
}

export type SearchAddUserFeedbackFeedback =
  (typeof SearchAddUserFeedbackFeedback)[keyof typeof SearchAddUserFeedbackFeedback];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SearchAddUserFeedbackFeedback = {
  like: "like",
  dislike: "dislike",
} as const;

export interface SearchAddUserFeedbackParams {
  response_index: number;
  feedback: SearchAddUserFeedbackFeedback;
}

export interface SearchSearchByQueryParams {
  query: string;
  limit?: number;
  use_ai?: boolean;
}

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

export type TelegramSourceType =
  (typeof TelegramSourceType)[keyof typeof TelegramSourceType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TelegramSourceType = {
  telegram: "telegram",
} as const;

export interface TelegramSource {
  /** Breadcrumbs to the resource. */
  breadcrumbs: string[];
  /** Title of the chat, channel, group */
  chat_title: string;
  /** Username of the chat, channel, group */
  chat_username: string;
  /** Display name of the resource. */
  display_name: string;
  /** Link to the message */
  link: string;
  /** Message ID in the chat */
  message_id: number;
  type: TelegramSourceType;
}

export type SearchTaskStatus =
  (typeof SearchTaskStatus)[keyof typeof SearchTaskStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SearchTaskStatus = {
  pending: "pending",
  completed: "completed",
  failed: "failed",
} as const;

export interface SearchTask {
  query: string;
  status: SearchTaskStatus;
  task_id: string;
}

export type SearchResultStatus =
  (typeof SearchResultStatus)[keyof typeof SearchResultStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SearchResultStatus = {
  completed: "completed",
  failed: "failed",
} as const;

export interface SearchResult {
  result?: MoodleFileResult[];
  status: SearchResultStatus;
  task_id: string;
}

/**
 * Assigned search query index
 */
export type SearchResponsesSearchQueryId = string | null;

export interface SearchResponses {
  /** Responses to the search query. */
  responses: SearchResponse[];
  /** Assigned search query index */
  search_query_id: SearchResponsesSearchQueryId;
  /** Text that was searched for. */
  searched_for: string;
}

/**
 * Relevant source for the search.
 */
export type SearchResponseSource = MoodleSource | TelegramSource;

/**
 * Score of the search response. Multiple scores if was an aggregation of multiple chunks. Optional.
 */
export type SearchResponseScore = number | number[] | null;

export interface SearchResponse {
  /** Score of the search response. Multiple scores if was an aggregation of multiple chunks. Optional. */
  score: SearchResponseScore;
  /** Relevant source for the search. */
  source: SearchResponseSource;
}

export interface PdfLocation {
  /** Page index in the PDF file. Starts from 1. */
  page_index: number;
}

export type MoodleSourceType =
  (typeof MoodleSourceType)[keyof typeof MoodleSourceType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MoodleSourceType = {
  moodle: "moodle",
} as const;

/**
 * URL to get the preview of the resource.
 */
export type MoodleSourceResourcePreviewUrl = string | null;

/**
 * URL to download the resource.
 */
export type MoodleSourceResourceDownloadUrl = string | null;

export type MoodleSourcePreviewLocation = PdfLocation | null;

export interface MoodleSource {
  /** Breadcrumbs to the resource. */
  breadcrumbs: string[];
  /** Display name of the resource. */
  display_name: string;
  /** Anchor URL to the resource on Moodle. */
  link: string;
  preview_location: MoodleSourcePreviewLocation;
  /** URL to download the resource. */
  resource_download_url: MoodleSourceResourceDownloadUrl;
  /** URL to get the preview of the resource. */
  resource_preview_url: MoodleSourceResourcePreviewUrl;
  type: MoodleSourceType;
}

export type MoodleFileResultScore = number[] | number | null;

export interface MoodleFileResult {
  course_id: number;
  filename: string;
  module_id: number;
  score?: MoodleFileResultScore;
}

export type MoodleEntrySectionSummary = string | null;

export type MoodleEntrySectionId = number | null;

export interface MoodleEntry {
  contents: MoodleContentSchemaOutput[];
  course_fullname: string;
  course_id: number;
  /** MongoDB document ObjectID */
  id: string;
  module_id: number;
  module_modname: string;
  module_name: string;
  section_id: MoodleEntrySectionId;
  section_summary: MoodleEntrySectionSummary;
}

export interface MoodleCourse {
  course_id: number;
  coursecategory: string;
  enddate: number;
  fullname: string;
  /** MongoDB document ObjectID */
  id: string;
  startdate: number;
}

export type MoodleContentSchemaOutputTimemodified = number | null;

export type MoodleContentSchemaOutputTimecreated = number | null;

export interface MoodleContentSchemaOutput {
  filename: string;
  timecreated: MoodleContentSchemaOutputTimecreated;
  timemodified: MoodleContentSchemaOutputTimemodified;
  type: string;
}

export type MoodleContentSchemaInputTimemodified = number | null;

export type MoodleContentSchemaInputTimecreated = number | null;

export interface MoodleContentSchemaInput {
  filename: string;
  timecreated?: MoodleContentSchemaInputTimecreated;
  timemodified?: MoodleContentSchemaInputTimemodified;
  type: string;
}

export type MessageSchemaText = string | null;

export type MessageSchemaCaption = string | null;

export interface MessageSchema {
  caption: MessageSchemaCaption;
  chat: Chat;
  date: string;
  id: number;
  sender_chat: Chat;
  text: MessageSchemaText;
}

export interface InModule {
  contents?: MoodleContentSchemaInput[];
  id: number;
  modname: string;
  name: string;
}

export interface InSection {
  id: number;
  modules: InModule[];
  summary: string;
}

export interface InSections {
  course_fullname: string;
  course_id: number;
  sections: InSection[];
}

export interface InCourse {
  coursecategory: string;
  enddate: number;
  fullname: string;
  id: number;
  startdate: number;
}

export interface InCourses {
  courses: InCourse[];
}

export interface InContentsOutput {
  contents: MoodleContentSchemaOutput[];
  course_id: number;
  module_id: number;
}

export interface InContentsInput {
  contents: MoodleContentSchemaInput[];
  course_id: number;
  module_id: number;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

export interface Detail {
  detail: string;
}

export type DBMessageSchemaText = string | null;

export type DBMessageSchemaCaption = string | null;

export interface DBMessageSchema {
  caption: DBMessageSchemaCaption;
  chat_id: number;
  chat_title: string;
  chat_username: string;
  date: string;
  link: string;
  message_id: number;
  text: DBMessageSchemaText;
}

export interface Chat {
  id: number;
  title: string;
  type: string;
  username: string;
}

export interface BodyMoodleUploadContent {
  data: string;
  files: Blob[];
}

type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];

/**
 * @summary Search By Query
 */
export function searchSearchByQuery(
  params: MaybeRef<SearchSearchByQueryParams>,
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) {
  params = unref(params);

  return axiosQuery<SearchResponses>(
    { url: `/search/search`, method: "GET", params: unref(params), signal },
    options,
  );
}

export function useSearchSearchByQueryQueryOptions<
  TData = Awaited<ReturnType<typeof searchSearchByQuery>>,
  TError = void | HTTPValidationError,
>(
  params: MaybeRef<SearchSearchByQueryParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchSearchByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof axiosQuery>;
  },
) {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryKeyMutator(
    { params },
    { url: `/search/search`, queryOptions },
  );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof searchSearchByQuery>>
  > = ({ signal }) => searchSearchByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof searchSearchByQuery>>,
    TError,
    TData
  >;
}

export type SearchSearchByQueryQueryResult = NonNullable<
  Awaited<ReturnType<typeof searchSearchByQuery>>
>;
export type SearchSearchByQueryQueryError = void | HTTPValidationError;

/**
 * @summary Search By Query
 */
export function useSearchSearchByQuery<
  TData = Awaited<ReturnType<typeof searchSearchByQuery>>,
  TError = void | HTTPValidationError,
>(
  params: MaybeRef<SearchSearchByQueryParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchSearchByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof axiosQuery>;
  },
): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = useSearchSearchByQueryQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = unref(queryOptions).queryKey as QueryKey;

  return query;
}

/**
 * @summary Add User Feedback
 */
export function searchAddUserFeedback(
  searchQueryId: MaybeRef<string>,
  params: MaybeRef<SearchAddUserFeedbackParams>,
  options?: SecondParameter<typeof axiosQuery>,
) {
  searchQueryId = unref(searchQueryId);
  params = unref(params);

  return axiosQuery<unknown>(
    {
      url: `/search/search/${searchQueryId}/feedback`,
      method: "POST",
      params: unref(params),
    },
    options,
  );
}

export function getSearchAddUserFeedbackMutationOptions<
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof searchAddUserFeedback>>,
    TError,
    { searchQueryId: string; params: SearchAddUserFeedbackParams },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof searchAddUserFeedback>>,
  TError,
  { searchQueryId: string; params: SearchAddUserFeedbackParams },
  TContext
> {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof searchAddUserFeedback>>,
    { searchQueryId: string; params: SearchAddUserFeedbackParams }
  > = (props) => {
    const { searchQueryId, params } = props ?? {};

    return searchAddUserFeedback(searchQueryId, params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
}

export type SearchAddUserFeedbackMutationResult = NonNullable<
  Awaited<ReturnType<typeof searchAddUserFeedback>>
>;

export type SearchAddUserFeedbackMutationError = HTTPValidationError;

/**
 * @summary Add User Feedback
 */
export function useSearchAddUserFeedback<
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof searchAddUserFeedback>>,
    TError,
    { searchQueryId: string; params: SearchAddUserFeedbackParams },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationReturnType<
  Awaited<ReturnType<typeof searchAddUserFeedback>>,
  TError,
  { searchQueryId: string; params: SearchAddUserFeedbackParams },
  TContext
> {
  const mutationOptions = getSearchAddUserFeedbackMutationOptions(options);

  return useMutation(mutationOptions);
}

/**
 * Determining whether to save the message or overwrite it
 * @summary Save Or Update Message
 */
export function telegramSaveOrUpdateMessage(
  messageSchema: MaybeRef<MessageSchema>,
  options?: SecondParameter<typeof axiosQuery>,
) {
  messageSchema = unref(messageSchema);

  return axiosQuery<DBMessageSchema>(
    {
      url: `/telegram/messages`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: messageSchema,
    },
    options,
  );
}

export function getTelegramSaveOrUpdateMessageMutationOptions<
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof telegramSaveOrUpdateMessage>>,
    TError,
    { data: MessageSchema },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof telegramSaveOrUpdateMessage>>,
  TError,
  { data: MessageSchema },
  TContext
> {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof telegramSaveOrUpdateMessage>>,
    { data: MessageSchema }
  > = (props) => {
    const { data } = props ?? {};

    return telegramSaveOrUpdateMessage(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
}

export type TelegramSaveOrUpdateMessageMutationResult = NonNullable<
  Awaited<ReturnType<typeof telegramSaveOrUpdateMessage>>
>;
export type TelegramSaveOrUpdateMessageMutationBody = MessageSchema;
export type TelegramSaveOrUpdateMessageMutationError = HTTPValidationError;

/**
 * @summary Save Or Update Message
 */
export function useTelegramSaveOrUpdateMessage<
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof telegramSaveOrUpdateMessage>>,
    TError,
    { data: MessageSchema },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationReturnType<
  Awaited<ReturnType<typeof telegramSaveOrUpdateMessage>>,
  TError,
  { data: MessageSchema },
  TContext
> {
  const mutationOptions =
    getTelegramSaveOrUpdateMessageMutationOptions(options);

  return useMutation(mutationOptions);
}

/**
 * @summary Preview Moodle
 */
export function moodlePreviewMoodle(
  params: MaybeRef<MoodlePreviewMoodleParams>,
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) {
  params = unref(params);

  return axiosQuery<unknown>(
    { url: `/moodle/preview`, method: "GET", params: unref(params), signal },
    options,
  );
}

export function useMoodlePreviewMoodleQueryOptions<
  TData = Awaited<ReturnType<typeof moodlePreviewMoodle>>,
  TError = void | HTTPValidationError,
>(
  params: MaybeRef<MoodlePreviewMoodleParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moodlePreviewMoodle>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof axiosQuery>;
  },
) {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryKeyMutator(
    { params },
    { url: `/moodle/preview`, queryOptions },
  );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof moodlePreviewMoodle>>
  > = ({ signal }) => moodlePreviewMoodle(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof moodlePreviewMoodle>>,
    TError,
    TData
  >;
}

export type MoodlePreviewMoodleQueryResult = NonNullable<
  Awaited<ReturnType<typeof moodlePreviewMoodle>>
>;
export type MoodlePreviewMoodleQueryError = void | HTTPValidationError;

/**
 * @summary Preview Moodle
 */
export function useMoodlePreviewMoodle<
  TData = Awaited<ReturnType<typeof moodlePreviewMoodle>>,
  TError = void | HTTPValidationError,
>(
  params: MaybeRef<MoodlePreviewMoodleParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moodlePreviewMoodle>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof axiosQuery>;
  },
): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = useMoodlePreviewMoodleQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = unref(queryOptions).queryKey as QueryKey;

  return query;
}

/**
 * @summary Get Moodle Files
 */
export function moodleGetMoodleFiles(
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) {
  return axiosQuery<MoodleGetMoodleFiles200Item[]>(
    { url: `/moodle/files`, method: "GET", signal },
    options,
  );
}

export function useMoodleGetMoodleFilesQueryOptions<
  TData = Awaited<ReturnType<typeof moodleGetMoodleFiles>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof moodleGetMoodleFiles>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof axiosQuery>;
}) {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryKeyMutator({}, { url: `/moodle/files`, queryOptions });

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof moodleGetMoodleFiles>>
  > = ({ signal }) => moodleGetMoodleFiles(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof moodleGetMoodleFiles>>,
    TError,
    TData
  >;
}

export type MoodleGetMoodleFilesQueryResult = NonNullable<
  Awaited<ReturnType<typeof moodleGetMoodleFiles>>
>;
export type MoodleGetMoodleFilesQueryError = unknown;

/**
 * @summary Get Moodle Files
 */
export function useMoodleGetMoodleFiles<
  TData = Awaited<ReturnType<typeof moodleGetMoodleFiles>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof moodleGetMoodleFiles>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = useMoodleGetMoodleFilesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = unref(queryOptions).queryKey as QueryKey;

  return query;
}

/**
 * @summary Batch Upsert Courses
 */
export function moodleBatchUpsertCourses(
  inCourses: MaybeRef<InCourses>,
  options?: SecondParameter<typeof axiosQuery>,
) {
  inCourses = unref(inCourses);

  return axiosQuery<unknown>(
    {
      url: `/moodle/batch-courses`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: inCourses,
    },
    options,
  );
}

export function getMoodleBatchUpsertCoursesMutationOptions<
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof moodleBatchUpsertCourses>>,
    TError,
    { data: InCourses },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof moodleBatchUpsertCourses>>,
  TError,
  { data: InCourses },
  TContext
> {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof moodleBatchUpsertCourses>>,
    { data: InCourses }
  > = (props) => {
    const { data } = props ?? {};

    return moodleBatchUpsertCourses(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
}

export type MoodleBatchUpsertCoursesMutationResult = NonNullable<
  Awaited<ReturnType<typeof moodleBatchUpsertCourses>>
>;
export type MoodleBatchUpsertCoursesMutationBody = InCourses;
export type MoodleBatchUpsertCoursesMutationError = HTTPValidationError;

/**
 * @summary Batch Upsert Courses
 */
export function useMoodleBatchUpsertCourses<
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof moodleBatchUpsertCourses>>,
    TError,
    { data: InCourses },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationReturnType<
  Awaited<ReturnType<typeof moodleBatchUpsertCourses>>,
  TError,
  { data: InCourses },
  TContext
> {
  const mutationOptions = getMoodleBatchUpsertCoursesMutationOptions(options);

  return useMutation(mutationOptions);
}

/**
 * @summary Courses
 */
export function moodleCourses(
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) {
  return axiosQuery<MoodleCourse[]>(
    { url: `/moodle/courses`, method: "GET", signal },
    options,
  );
}

export function useMoodleCoursesQueryOptions<
  TData = Awaited<ReturnType<typeof moodleCourses>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof moodleCourses>>, TError, TData>
  >;
  request?: SecondParameter<typeof axiosQuery>;
}) {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryKeyMutator(
    {},
    { url: `/moodle/courses`, queryOptions },
  );

  const queryFn: QueryFunction<Awaited<ReturnType<typeof moodleCourses>>> = ({
    signal,
  }) => moodleCourses(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof moodleCourses>>,
    TError,
    TData
  >;
}

export type MoodleCoursesQueryResult = NonNullable<
  Awaited<ReturnType<typeof moodleCourses>>
>;
export type MoodleCoursesQueryError = unknown;

/**
 * @summary Courses
 */
export function useMoodleCourses<
  TData = Awaited<ReturnType<typeof moodleCourses>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof moodleCourses>>, TError, TData>
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = useMoodleCoursesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = unref(queryOptions).queryKey as QueryKey;

  return query;
}

/**
 * @summary Course Content
 */
export function moodleCourseContent(
  inSections: MaybeRef<InSections>,
  options?: SecondParameter<typeof axiosQuery>,
) {
  inSections = unref(inSections);

  return axiosQuery<unknown>(
    {
      url: `/moodle/set-course-content`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: inSections,
    },
    options,
  );
}

export function getMoodleCourseContentMutationOptions<
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof moodleCourseContent>>,
    TError,
    { data: InSections },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof moodleCourseContent>>,
  TError,
  { data: InSections },
  TContext
> {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof moodleCourseContent>>,
    { data: InSections }
  > = (props) => {
    const { data } = props ?? {};

    return moodleCourseContent(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
}

export type MoodleCourseContentMutationResult = NonNullable<
  Awaited<ReturnType<typeof moodleCourseContent>>
>;
export type MoodleCourseContentMutationBody = InSections;
export type MoodleCourseContentMutationError = HTTPValidationError;

/**
 * @summary Course Content
 */
export function useMoodleCourseContent<
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof moodleCourseContent>>,
    TError,
    { data: InSections },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationReturnType<
  Awaited<ReturnType<typeof moodleCourseContent>>,
  TError,
  { data: InSections },
  TContext
> {
  const mutationOptions = getMoodleCourseContentMutationOptions(options);

  return useMutation(mutationOptions);
}

/**
 * @summary Courses Content
 */
export function moodleCoursesContent(
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) {
  return axiosQuery<MoodleEntry[]>(
    { url: `/moodle/courses-content`, method: "GET", signal },
    options,
  );
}

export function useMoodleCoursesContentQueryOptions<
  TData = Awaited<ReturnType<typeof moodleCoursesContent>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof moodleCoursesContent>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof axiosQuery>;
}) {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryKeyMutator(
    {},
    { url: `/moodle/courses-content`, queryOptions },
  );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof moodleCoursesContent>>
  > = ({ signal }) => moodleCoursesContent(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof moodleCoursesContent>>,
    TError,
    TData
  >;
}

export type MoodleCoursesContentQueryResult = NonNullable<
  Awaited<ReturnType<typeof moodleCoursesContent>>
>;
export type MoodleCoursesContentQueryError = unknown;

/**
 * @summary Courses Content
 */
export function useMoodleCoursesContent<
  TData = Awaited<ReturnType<typeof moodleCoursesContent>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof moodleCoursesContent>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = useMoodleCoursesContentQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = unref(queryOptions).queryKey as QueryKey;

  return query;
}

/**
 * @summary Need To Upload Contents
 */
export function moodleNeedToUploadContents(
  inContentsInput: MaybeRef<InContentsInput[]>,
  options?: SecondParameter<typeof axiosQuery>,
) {
  inContentsInput = unref(inContentsInput);

  return axiosQuery<InContentsOutput[]>(
    {
      url: `/moodle/need-to-upload-contents`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: inContentsInput,
    },
    options,
  );
}

export function getMoodleNeedToUploadContentsMutationOptions<
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof moodleNeedToUploadContents>>,
    TError,
    { data: InContentsInput[] },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof moodleNeedToUploadContents>>,
  TError,
  { data: InContentsInput[] },
  TContext
> {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof moodleNeedToUploadContents>>,
    { data: InContentsInput[] }
  > = (props) => {
    const { data } = props ?? {};

    return moodleNeedToUploadContents(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
}

export type MoodleNeedToUploadContentsMutationResult = NonNullable<
  Awaited<ReturnType<typeof moodleNeedToUploadContents>>
>;
export type MoodleNeedToUploadContentsMutationBody = InContentsInput[];
export type MoodleNeedToUploadContentsMutationError = HTTPValidationError;

/**
 * @summary Need To Upload Contents
 */
export function useMoodleNeedToUploadContents<
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof moodleNeedToUploadContents>>,
    TError,
    { data: InContentsInput[] },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationReturnType<
  Awaited<ReturnType<typeof moodleNeedToUploadContents>>,
  TError,
  { data: InContentsInput[] },
  TContext
> {
  const mutationOptions = getMoodleNeedToUploadContentsMutationOptions(options);

  return useMutation(mutationOptions);
}

/**
 * @summary Upload Content
 */
export function moodleUploadContent(
  bodyMoodleUploadContent: MaybeRef<BodyMoodleUploadContent>,
  options?: SecondParameter<typeof axiosQuery>,
) {
  bodyMoodleUploadContent = unref(bodyMoodleUploadContent);
  const formData = new FormData();
  bodyMoodleUploadContent.files.forEach((value) =>
    formData.append("files", value),
  );
  formData.append("data", bodyMoodleUploadContent.data);

  return axiosQuery<unknown>(
    {
      url: `/moodle/upload-contents`,
      method: "POST",
      headers: { "Content-Type": "multipart/form-data" },
      data: formData,
    },
    options,
  );
}

export function getMoodleUploadContentMutationOptions<
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof moodleUploadContent>>,
    TError,
    { data: BodyMoodleUploadContent },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof moodleUploadContent>>,
  TError,
  { data: BodyMoodleUploadContent },
  TContext
> {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof moodleUploadContent>>,
    { data: BodyMoodleUploadContent }
  > = (props) => {
    const { data } = props ?? {};

    return moodleUploadContent(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
}

export type MoodleUploadContentMutationResult = NonNullable<
  Awaited<ReturnType<typeof moodleUploadContent>>
>;
export type MoodleUploadContentMutationBody = BodyMoodleUploadContent;
export type MoodleUploadContentMutationError = HTTPValidationError;

/**
 * @summary Upload Content
 */
export function useMoodleUploadContent<
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof moodleUploadContent>>,
    TError,
    { data: BodyMoodleUploadContent },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationReturnType<
  Awaited<ReturnType<typeof moodleUploadContent>>,
  TError,
  { data: BodyMoodleUploadContent },
  TContext
> {
  const mutationOptions = getMoodleUploadContentMutationOptions(options);

  return useMutation(mutationOptions);
}

/**
 * @summary Get Corpora
 */
export function computeGetCorpora(
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) {
  return axiosQuery<unknown>(
    { url: `/compute/corpora`, method: "GET", signal },
    options,
  );
}

export function useComputeGetCorporaQueryOptions<
  TData = Awaited<ReturnType<typeof computeGetCorpora>>,
  TError = Detail,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof computeGetCorpora>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof axiosQuery>;
}) {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryKeyMutator(
    {},
    { url: `/compute/corpora`, queryOptions },
  );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof computeGetCorpora>>
  > = ({ signal }) => computeGetCorpora(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof computeGetCorpora>>,
    TError,
    TData
  >;
}

export type ComputeGetCorporaQueryResult = NonNullable<
  Awaited<ReturnType<typeof computeGetCorpora>>
>;
export type ComputeGetCorporaQueryError = Detail;

/**
 * @summary Get Corpora
 */
export function useComputeGetCorpora<
  TData = Awaited<ReturnType<typeof computeGetCorpora>>,
  TError = Detail,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof computeGetCorpora>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = useComputeGetCorporaQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = unref(queryOptions).queryKey as QueryKey;

  return query;
}

/**
 * @summary Get Pending Search Queries
 */
export function computeGetPendingSearchQueries(
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) {
  return axiosQuery<SearchTask[]>(
    { url: `/compute/pending-searchs`, method: "GET", signal },
    options,
  );
}

export function useComputeGetPendingSearchQueriesQueryOptions<
  TData = Awaited<ReturnType<typeof computeGetPendingSearchQueries>>,
  TError = Detail,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof computeGetPendingSearchQueries>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof axiosQuery>;
}) {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryKeyMutator(
    {},
    { url: `/compute/pending-searchs`, queryOptions },
  );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof computeGetPendingSearchQueries>>
  > = ({ signal }) => computeGetPendingSearchQueries(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof computeGetPendingSearchQueries>>,
    TError,
    TData
  >;
}

export type ComputeGetPendingSearchQueriesQueryResult = NonNullable<
  Awaited<ReturnType<typeof computeGetPendingSearchQueries>>
>;
export type ComputeGetPendingSearchQueriesQueryError = Detail;

/**
 * @summary Get Pending Search Queries
 */
export function useComputeGetPendingSearchQueries<
  TData = Awaited<ReturnType<typeof computeGetPendingSearchQueries>>,
  TError = Detail,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof computeGetPendingSearchQueries>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = useComputeGetPendingSearchQueriesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = unref(queryOptions).queryKey as QueryKey;

  return query;
}

/**
 * @summary Post Completed Search Queries
 */
export function computePostCompletedSearchQueries(
  searchResult: MaybeRef<SearchResult[]>,
  options?: SecondParameter<typeof axiosQuery>,
) {
  searchResult = unref(searchResult);

  return axiosQuery<unknown>(
    {
      url: `/compute/completed-searchs`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: searchResult,
    },
    options,
  );
}

export function getComputePostCompletedSearchQueriesMutationOptions<
  TError = Detail | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof computePostCompletedSearchQueries>>,
    TError,
    { data: SearchResult[] },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof computePostCompletedSearchQueries>>,
  TError,
  { data: SearchResult[] },
  TContext
> {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof computePostCompletedSearchQueries>>,
    { data: SearchResult[] }
  > = (props) => {
    const { data } = props ?? {};

    return computePostCompletedSearchQueries(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
}

export type ComputePostCompletedSearchQueriesMutationResult = NonNullable<
  Awaited<ReturnType<typeof computePostCompletedSearchQueries>>
>;
export type ComputePostCompletedSearchQueriesMutationBody = SearchResult[];
export type ComputePostCompletedSearchQueriesMutationError =
  | Detail
  | HTTPValidationError;

/**
 * @summary Post Completed Search Queries
 */
export function useComputePostCompletedSearchQueries<
  TError = Detail | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof computePostCompletedSearchQueries>>,
    TError,
    { data: SearchResult[] },
    TContext
  >;
  request?: SecondParameter<typeof axiosQuery>;
}): UseMutationReturnType<
  Awaited<ReturnType<typeof computePostCompletedSearchQueries>>,
  TError,
  { data: SearchResult[] },
  TContext
> {
  const mutationOptions =
    getComputePostCompletedSearchQueriesMutationOptions(options);

  return useMutation(mutationOptions);
}
