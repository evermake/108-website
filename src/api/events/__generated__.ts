/**
 * Generated by orval v6.29.1 üç∫
 * Do not edit manually.
 * InNoHassle Events API
 *
### About this project

This is the API for Events project in InNoHassle ecosystem developed by one-zero-eight community.

Using this API you can browse, view, create and edit schedules at Innopolis University.

Backend is developed using FastAPI framework on Python.

Note: API is unstable. Endpoints and models may change in the future.

Useful links:
- [Backend source code](https://github.com/one-zero-eight/InNoHassle-Events)
- [Frontend source code](https://github.com/one-zero-eight/InNoHassle-Website)
- [Website](https://innohassle.ru/schedule)

 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery } from '@tanstack/vue-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationReturnType,
  UseQueryOptions,
  UseQueryReturnType,
} from '@tanstack/vue-query'
import { computed, unref } from 'vue'
import type { MaybeRef } from 'vue'
import { axiosQuery } from './axios'
import { queryKeyMutator } from './query'

export interface IcsGetEventGroupIcsByAliasParams {
  user_id: number
  export_type: string
}

export interface IcsGetSportUserScheduleParams {
  access_key: string
}

export interface IcsGetMusicRoomUserScheduleParams {
  access_key: string
}

export interface IcsGetUserScheduleParams {
  access_key: string
}

export interface EventGroupsDeleteEventGroupByAliasParams {
  alias: string
}

export interface EventGroupsFindEventGroupByAliasParams {
  alias: string
}

export interface EventGroupsFindEventGroupByPathParams {
  path: string
}

export interface UsersDeleteUserScheduleKeyParams {
  access_key: string
  resource_path: string
}

export interface UsersGenerateUserScheduleKeyParams {
  resource_path: string
}

export interface UsersHideTargetParams {
  hide?: boolean
}

export interface UsersHideFavoriteParams {
  group_id: number
  hide?: boolean
}

export interface UsersDeleteFavoriteParams {
  group_id: number
}

export interface UsersAddFavoriteParams {
  group_id: number
}

/**
 * Represents a user schedule key.
 */
export interface ViewUserScheduleKey {
  access_key: string
  resource_path: string
  user_id: number
}

export interface _GetScheduleAccessKeyResponse {
  access_key: ViewUserScheduleKey
  new: boolean
}

export type ViewUserName = string | null

export interface ViewUserLinkedCalendars {
  [key: string]: LinkedCalendarView
}

export type ViewUserInnohassleId = string | null

/**
 * Represents a user instance from the database excluding sensitive information.
 */
export interface ViewUser {
  email: string
  favorite_event_groups?: number[]
  hidden_event_groups?: number[]
  id: number
  innohassle_id?: ViewUserInnohassleId
  linked_calendars?: ViewUserLinkedCalendars
  moodle_hidden: boolean
  music_room_hidden: boolean
  name?: ViewUserName
  sports_hidden: boolean
}

export type ViewTagType = string | null

export interface ViewTagSatelliteAnyOf {
  [key: string]: any
}

export type ViewTagSatellite = ViewTagSatelliteAnyOf | null

export type ViewTagName = string | null

export interface ViewTag {
  alias: string
  id: number
  name?: ViewTagName
  satellite?: ViewTagSatellite
  type?: ViewTagType
}

export type ViewEventGroupPath = string | null

export type ViewEventGroupName = string | null

export type ViewEventGroupDescription = string | null

/**
 * Represents a group instance from the database excluding sensitive information.
 */
export interface ViewEventGroup {
  alias: string
  created_at: string
  description?: ViewEventGroupDescription
  id: number
  name?: ViewEventGroupName
  path?: ViewEventGroupPath
  tags?: ViewTag[]
  updated_at: string
}

export type ValidationErrorLocItem = string | number

export interface ValidationError {
  loc: ValidationErrorLocItem[]
  msg: string
  type: string
}

export interface UserPredefinedGroupsResponse {
  event_groups: number[]
}

export type UpdateEventGroupPath = string | null

export type UpdateEventGroupName = string | null

export type UpdateEventGroupDescription = string | null

export type UpdateEventGroupAlias = string | null

/**
 * Represents a group instance to be updated.
 */
export interface UpdateEventGroup {
  alias?: UpdateEventGroupAlias
  description?: UpdateEventGroupDescription
  name?: UpdateEventGroupName
  path?: UpdateEventGroupPath
}

export interface ListTagsResponse {
  tags: ViewTag[]
}

/**
 * Represents a list of event groups.
 */
export interface ListEventGroupsResponseOutput {
  event_groups: ViewEventGroup[]
}

/**
 * Represents a list of event groups.
 */
export interface ListEventGroupsResponseInput {
  event_groups: ViewEventGroup[]
}

export type LinkedCalendarViewName = string | null

export type LinkedCalendarViewDescription = string | null

export type LinkedCalendarViewColor = string | null

/**
 * Represents a linked calendar instance from the database excluding sensitive information.
 */
export interface LinkedCalendarView {
  alias: string
  color?: LinkedCalendarViewColor
  description?: LinkedCalendarViewDescription
  id: number
  is_active?: boolean
  name?: LinkedCalendarViewName
  url: string
  user_id: number
}

export type LinkedCalendarCreateName = string | null

export type LinkedCalendarCreateDescription = string | null

export type LinkedCalendarCreateColor = string | null

/**
 * Represents a linked calendar instance to be created.
 */
export interface LinkedCalendarCreate {
  alias: string
  color?: LinkedCalendarCreateColor
  description?: LinkedCalendarCreateDescription
  is_active?: boolean
  name?: LinkedCalendarCreateName
  url: string
}

export interface HTTPValidationError {
  detail?: ValidationError[]
}

export type CreateTagType = string | null

export type CreateTagSatellite = string | null

export type CreateTagName = string | null

export interface CreateTag {
  alias: string
  name?: CreateTagName
  satellite?: CreateTagSatellite
  type?: CreateTagType
}

export type CreateEventGroupPath = string | null

export type CreateEventGroupDescription = string | null

export interface CreateEventGroup {
  alias: string
  description?: CreateEventGroupDescription
  name: string
  path?: CreateEventGroupPath
  tags?: CreateTag[]
}

export interface BodyTagsBatchCreateTags {
  tags: CreateTag[]
}

export interface BodyEventGroupsSetEventGroupIcs {
  ics_file: Blob
}

export interface BodyEventGroupsBatchCreateEventGroups {
  event_groups: CreateEventGroup[]
}

type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1]

/**
 * Get current user info if authenticated
 * @summary Get Me
 */
export function usersGetMe(
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) {
  return axiosQuery<ViewUser>(
    { url: `/users/me`, method: 'GET', signal },
    options,
  )
}

export function useUsersGetMeQueryOptions<
  TData = Awaited<ReturnType<typeof usersGetMe>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof usersGetMe>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosQuery>
}) {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryKeyMutator({}, { url: `/users/me`, queryOptions })

  const queryFn: QueryFunction<Awaited<ReturnType<typeof usersGetMe>>> = ({
    signal,
  }) => usersGetMe(requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof usersGetMe>>,
    TError,
    TData
  >
}

export type UsersGetMeQueryResult = NonNullable<
  Awaited<ReturnType<typeof usersGetMe>>
>
export type UsersGetMeQueryError = void

/**
 * @summary Get Me
 */
export function useUsersGetMe<
  TData = Awaited<ReturnType<typeof usersGetMe>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof usersGetMe>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = useUsersGetMeQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = unref(queryOptions).queryKey as QueryKey

  return query
}

/**
 * Get predefined event groups for user
 * @summary Get Predefined
 */
export function usersGetPredefined(
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) {
  return axiosQuery<UserPredefinedGroupsResponse>(
    { url: `/users/me/predefined`, method: 'GET', signal },
    options,
  )
}

export function useUsersGetPredefinedQueryOptions<
  TData = Awaited<ReturnType<typeof usersGetPredefined>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof usersGetPredefined>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosQuery>
}) {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryKeyMutator(
    {},
    { url: `/users/me/predefined`, queryOptions },
  )

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof usersGetPredefined>>
  > = ({ signal }) => usersGetPredefined(requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof usersGetPredefined>>,
    TError,
    TData
  >
}

export type UsersGetPredefinedQueryResult = NonNullable<
  Awaited<ReturnType<typeof usersGetPredefined>>
>
export type UsersGetPredefinedQueryError = void

/**
 * @summary Get Predefined
 */
export function useUsersGetPredefined<
  TData = Awaited<ReturnType<typeof usersGetPredefined>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof usersGetPredefined>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = useUsersGetPredefinedQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = unref(queryOptions).queryKey as QueryKey

  return query
}

/**
 * Add favorite to current user
 * @summary Add Favorite
 */
export function usersAddFavorite(
  params: MaybeRef<UsersAddFavoriteParams>,
  options?: SecondParameter<typeof axiosQuery>,
) {
  params = unref(params)

  return axiosQuery<ViewUser>(
    { url: `/users/me/favorites`, method: 'POST', params: unref(params) },
    options,
  )
}

export function getUsersAddFavoriteMutationOptions<
  TError = void | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersAddFavorite>>,
    TError,
    { params: UsersAddFavoriteParams },
    TContext
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseMutationOptions<
    Awaited<ReturnType<typeof usersAddFavorite>>,
    TError,
    { params: UsersAddFavoriteParams },
    TContext
  > {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof usersAddFavorite>>,
    { params: UsersAddFavoriteParams }
  > = (props) => {
    const { params } = props ?? {}

    return usersAddFavorite(params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UsersAddFavoriteMutationResult = NonNullable<
  Awaited<ReturnType<typeof usersAddFavorite>>
>

export type UsersAddFavoriteMutationError = void | HTTPValidationError

/**
 * @summary Add Favorite
 */
export function useUsersAddFavorite<
  TError = void | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersAddFavorite>>,
    TError,
    { params: UsersAddFavoriteParams },
    TContext
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseMutationReturnType<
    Awaited<ReturnType<typeof usersAddFavorite>>,
    TError,
    { params: UsersAddFavoriteParams },
    TContext
  > {
  const mutationOptions = getUsersAddFavoriteMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Delete favorite from current user
 * @summary Delete Favorite
 */
export function usersDeleteFavorite(
  params: MaybeRef<UsersDeleteFavoriteParams>,
  options?: SecondParameter<typeof axiosQuery>,
) {
  params = unref(params)

  return axiosQuery<ViewUser>(
    { url: `/users/me/favorites`, method: 'DELETE', params: unref(params) },
    options,
  )
}

export function getUsersDeleteFavoriteMutationOptions<
  TError = void | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersDeleteFavorite>>,
    TError,
    { params: UsersDeleteFavoriteParams },
    TContext
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseMutationOptions<
    Awaited<ReturnType<typeof usersDeleteFavorite>>,
    TError,
    { params: UsersDeleteFavoriteParams },
    TContext
  > {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof usersDeleteFavorite>>,
    { params: UsersDeleteFavoriteParams }
  > = (props) => {
    const { params } = props ?? {}

    return usersDeleteFavorite(params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UsersDeleteFavoriteMutationResult = NonNullable<
  Awaited<ReturnType<typeof usersDeleteFavorite>>
>

export type UsersDeleteFavoriteMutationError = void | HTTPValidationError

/**
 * @summary Delete Favorite
 */
export function useUsersDeleteFavorite<
  TError = void | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersDeleteFavorite>>,
    TError,
    { params: UsersDeleteFavoriteParams },
    TContext
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseMutationReturnType<
    Awaited<ReturnType<typeof usersDeleteFavorite>>,
    TError,
    { params: UsersDeleteFavoriteParams },
    TContext
  > {
  const mutationOptions = getUsersDeleteFavoriteMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Hide favorite from current user
 * @summary Hide Favorite
 */
export function usersHideFavorite(
  params: MaybeRef<UsersHideFavoriteParams>,
  options?: SecondParameter<typeof axiosQuery>,
) {
  params = unref(params)

  return axiosQuery<ViewUser>(
    { url: `/users/me/favorites/hide`, method: 'POST', params: unref(params) },
    options,
  )
}

export function getUsersHideFavoriteMutationOptions<
  TError = void | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersHideFavorite>>,
    TError,
    { params: UsersHideFavoriteParams },
    TContext
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseMutationOptions<
    Awaited<ReturnType<typeof usersHideFavorite>>,
    TError,
    { params: UsersHideFavoriteParams },
    TContext
  > {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof usersHideFavorite>>,
    { params: UsersHideFavoriteParams }
  > = (props) => {
    const { params } = props ?? {}

    return usersHideFavorite(params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UsersHideFavoriteMutationResult = NonNullable<
  Awaited<ReturnType<typeof usersHideFavorite>>
>

export type UsersHideFavoriteMutationError = void | HTTPValidationError

/**
 * @summary Hide Favorite
 */
export function useUsersHideFavorite<
  TError = void | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersHideFavorite>>,
    TError,
    { params: UsersHideFavoriteParams },
    TContext
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseMutationReturnType<
    Awaited<ReturnType<typeof usersHideFavorite>>,
    TError,
    { params: UsersHideFavoriteParams },
    TContext
  > {
  const mutationOptions = getUsersHideFavoriteMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Hide music room, sports or moodle from current user
 * @summary Hide Target
 */
export function usersHideTarget(
  target: MaybeRef<'music-room' | 'sports' | 'moodle'>,
  params?: MaybeRef<UsersHideTargetParams>,
  options?: SecondParameter<typeof axiosQuery>,
) {
  target = unref(target)
  params = unref(params)

  return axiosQuery<ViewUser>(
    { url: `/users/me/${target}/hide`, method: 'POST', params: unref(params) },
    options,
  )
}

export function getUsersHideTargetMutationOptions<
  TError = void | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersHideTarget>>,
    TError,
    {
      target: 'music-room' | 'sports' | 'moodle'
      params?: UsersHideTargetParams
    },
    TContext
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseMutationOptions<
    Awaited<ReturnType<typeof usersHideTarget>>,
    TError,
    {
      target: 'music-room' | 'sports' | 'moodle'
      params?: UsersHideTargetParams
    },
    TContext
  > {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof usersHideTarget>>,
    {
      target: 'music-room' | 'sports' | 'moodle'
      params?: UsersHideTargetParams
    }
  > = (props) => {
    const { target, params } = props ?? {}

    return usersHideTarget(target, params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UsersHideTargetMutationResult = NonNullable<
  Awaited<ReturnType<typeof usersHideTarget>>
>

export type UsersHideTargetMutationError = void | HTTPValidationError

/**
 * @summary Hide Target
 */
export function useUsersHideTarget<
  TError = void | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersHideTarget>>,
    TError,
    {
      target: 'music-room' | 'sports' | 'moodle'
      params?: UsersHideTargetParams
    },
    TContext
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseMutationReturnType<
    Awaited<ReturnType<typeof usersHideTarget>>,
    TError,
    {
      target: 'music-room' | 'sports' | 'moodle'
      params?: UsersHideTargetParams
    },
    TContext
  > {
  const mutationOptions = getUsersHideTargetMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Add linked calendar to current user
 * @summary Link Calendar
 */
export function usersLinkCalendar(
  linkedCalendarCreate: MaybeRef<LinkedCalendarCreate>,
  options?: SecondParameter<typeof axiosQuery>,
) {
  linkedCalendarCreate = unref(linkedCalendarCreate)

  return axiosQuery<LinkedCalendarView>(
    {
      url: `/users/me/linked`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: linkedCalendarCreate,
    },
    options,
  )
}

export function getUsersLinkCalendarMutationOptions<
  TError = void | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersLinkCalendar>>,
    TError,
    { data: LinkedCalendarCreate },
    TContext
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseMutationOptions<
    Awaited<ReturnType<typeof usersLinkCalendar>>,
    TError,
    { data: LinkedCalendarCreate },
    TContext
  > {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof usersLinkCalendar>>,
    { data: LinkedCalendarCreate }
  > = (props) => {
    const { data } = props ?? {}

    return usersLinkCalendar(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UsersLinkCalendarMutationResult = NonNullable<
  Awaited<ReturnType<typeof usersLinkCalendar>>
>
export type UsersLinkCalendarMutationBody = LinkedCalendarCreate
export type UsersLinkCalendarMutationError = void | HTTPValidationError

/**
 * @summary Link Calendar
 */
export function useUsersLinkCalendar<
  TError = void | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersLinkCalendar>>,
    TError,
    { data: LinkedCalendarCreate },
    TContext
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseMutationReturnType<
    Awaited<ReturnType<typeof usersLinkCalendar>>,
    TError,
    { data: LinkedCalendarCreate },
    TContext
  > {
  const mutationOptions = getUsersLinkCalendarMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Generate an access key for the user schedule
 * @summary Generate User Schedule Key
 */
export function usersGenerateUserScheduleKey(
  params: MaybeRef<UsersGenerateUserScheduleKeyParams>,
  options?: SecondParameter<typeof axiosQuery>,
) {
  params = unref(params)

  return axiosQuery<_GetScheduleAccessKeyResponse>(
    {
      url: `/users/me/get-schedule-access-key`,
      method: 'POST',
      params: unref(params),
    },
    options,
  )
}

export function getUsersGenerateUserScheduleKeyMutationOptions<
  TError = void | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersGenerateUserScheduleKey>>,
    TError,
    { params: UsersGenerateUserScheduleKeyParams },
    TContext
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseMutationOptions<
    Awaited<ReturnType<typeof usersGenerateUserScheduleKey>>,
    TError,
    { params: UsersGenerateUserScheduleKeyParams },
    TContext
  > {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof usersGenerateUserScheduleKey>>,
    { params: UsersGenerateUserScheduleKeyParams }
  > = (props) => {
    const { params } = props ?? {}

    return usersGenerateUserScheduleKey(params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UsersGenerateUserScheduleKeyMutationResult = NonNullable<
  Awaited<ReturnType<typeof usersGenerateUserScheduleKey>>
>

export type UsersGenerateUserScheduleKeyMutationError =
  void | HTTPValidationError

/**
 * @summary Generate User Schedule Key
 */
export function useUsersGenerateUserScheduleKey<
  TError = void | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersGenerateUserScheduleKey>>,
    TError,
    { params: UsersGenerateUserScheduleKeyParams },
    TContext
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseMutationReturnType<
    Awaited<ReturnType<typeof usersGenerateUserScheduleKey>>,
    TError,
    { params: UsersGenerateUserScheduleKeyParams },
    TContext
  > {
  const mutationOptions
    = getUsersGenerateUserScheduleKeyMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Get all access keys for the user schedule
 * @summary Get User Schedule Keys
 */
export function usersGetUserScheduleKeys(
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) {
  return axiosQuery<ViewUserScheduleKey[]>(
    { url: `/users/me/schedule-access-keys`, method: 'GET', signal },
    options,
  )
}

export function useUsersGetUserScheduleKeysQueryOptions<
  TData = Awaited<ReturnType<typeof usersGetUserScheduleKeys>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof usersGetUserScheduleKeys>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosQuery>
}) {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryKeyMutator(
    {},
    { url: `/users/me/schedule-access-keys`, queryOptions },
  )

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof usersGetUserScheduleKeys>>
  > = ({ signal }) => usersGetUserScheduleKeys(requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof usersGetUserScheduleKeys>>,
    TError,
    TData
  >
}

export type UsersGetUserScheduleKeysQueryResult = NonNullable<
  Awaited<ReturnType<typeof usersGetUserScheduleKeys>>
>
export type UsersGetUserScheduleKeysQueryError = void

/**
 * @summary Get User Schedule Keys
 */
export function useUsersGetUserScheduleKeys<
  TData = Awaited<ReturnType<typeof usersGetUserScheduleKeys>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof usersGetUserScheduleKeys>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = useUsersGetUserScheduleKeysQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = unref(queryOptions).queryKey as QueryKey

  return query
}

/**
 * Delete an access key for the user schedule
 * @summary Delete User Schedule Key
 */
export function usersDeleteUserScheduleKey(
  params: MaybeRef<UsersDeleteUserScheduleKeyParams>,
  options?: SecondParameter<typeof axiosQuery>,
) {
  params = unref(params)

  return axiosQuery<unknown>(
    {
      url: `/users/me/schedule-access-key`,
      method: 'DELETE',
      params: unref(params),
    },
    options,
  )
}

export function getUsersDeleteUserScheduleKeyMutationOptions<
  TError = void | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersDeleteUserScheduleKey>>,
    TError,
    { params: UsersDeleteUserScheduleKeyParams },
    TContext
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseMutationOptions<
    Awaited<ReturnType<typeof usersDeleteUserScheduleKey>>,
    TError,
    { params: UsersDeleteUserScheduleKeyParams },
    TContext
  > {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof usersDeleteUserScheduleKey>>,
    { params: UsersDeleteUserScheduleKeyParams }
  > = (props) => {
    const { params } = props ?? {}

    return usersDeleteUserScheduleKey(params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UsersDeleteUserScheduleKeyMutationResult = NonNullable<
  Awaited<ReturnType<typeof usersDeleteUserScheduleKey>>
>

export type UsersDeleteUserScheduleKeyMutationError =
  void | HTTPValidationError

/**
 * @summary Delete User Schedule Key
 */
export function useUsersDeleteUserScheduleKey<
  TError = void | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersDeleteUserScheduleKey>>,
    TError,
    { params: UsersDeleteUserScheduleKeyParams },
    TContext
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseMutationReturnType<
    Awaited<ReturnType<typeof usersDeleteUserScheduleKey>>,
    TError,
    { params: UsersDeleteUserScheduleKeyParams },
    TContext
  > {
  const mutationOptions = getUsersDeleteUserScheduleKeyMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Get a list of all event groups
 * @summary List Event Groups
 */
export function eventGroupsListEventGroups(
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) {
  return axiosQuery<ListEventGroupsResponseInput>(
    { url: `/event-groups/`, method: 'GET', signal },
    options,
  )
}

export function useEventGroupsListEventGroupsQueryOptions<
  TData = Awaited<ReturnType<typeof eventGroupsListEventGroups>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof eventGroupsListEventGroups>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosQuery>
}) {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryKeyMutator({}, { url: `/event-groups/`, queryOptions })

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof eventGroupsListEventGroups>>
  > = ({ signal }) => eventGroupsListEventGroups(requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof eventGroupsListEventGroups>>,
    TError,
    TData
  >
}

export type EventGroupsListEventGroupsQueryResult = NonNullable<
  Awaited<ReturnType<typeof eventGroupsListEventGroups>>
>
export type EventGroupsListEventGroupsQueryError = unknown

/**
 * @summary List Event Groups
 */
export function useEventGroupsListEventGroups<
  TData = Awaited<ReturnType<typeof eventGroupsListEventGroups>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof eventGroupsListEventGroups>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = useEventGroupsListEventGroupsQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = unref(queryOptions).queryKey as QueryKey

  return query
}

/**
 * @summary Create Event Group
 */
export function eventGroupsCreateEventGroup(
  createEventGroup: MaybeRef<CreateEventGroup>,
  options?: SecondParameter<typeof axiosQuery>,
) {
  createEventGroup = unref(createEventGroup)

  return axiosQuery<ViewEventGroup>(
    {
      url: `/event-groups/`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createEventGroup,
    },
    options,
  )
}

export function getEventGroupsCreateEventGroupMutationOptions<
  TError = void | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof eventGroupsCreateEventGroup>>,
    TError,
    { data: CreateEventGroup },
    TContext
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseMutationOptions<
    Awaited<ReturnType<typeof eventGroupsCreateEventGroup>>,
    TError,
    { data: CreateEventGroup },
    TContext
  > {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof eventGroupsCreateEventGroup>>,
    { data: CreateEventGroup }
  > = (props) => {
    const { data } = props ?? {}

    return eventGroupsCreateEventGroup(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type EventGroupsCreateEventGroupMutationResult = NonNullable<
  Awaited<ReturnType<typeof eventGroupsCreateEventGroup>>
>
export type EventGroupsCreateEventGroupMutationBody = CreateEventGroup
export type EventGroupsCreateEventGroupMutationError =
  void | HTTPValidationError

/**
 * @summary Create Event Group
 */
export function useEventGroupsCreateEventGroup<
  TError = void | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof eventGroupsCreateEventGroup>>,
    TError,
    { data: CreateEventGroup },
    TContext
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseMutationReturnType<
    Awaited<ReturnType<typeof eventGroupsCreateEventGroup>>,
    TError,
    { data: CreateEventGroup },
    TContext
  > {
  const mutationOptions
    = getEventGroupsCreateEventGroupMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Batch Create Event Groups
 */
export function eventGroupsBatchCreateEventGroups(
  bodyEventGroupsBatchCreateEventGroups: MaybeRef<BodyEventGroupsBatchCreateEventGroups>,
  options?: SecondParameter<typeof axiosQuery>,
) {
  bodyEventGroupsBatchCreateEventGroups = unref(
    bodyEventGroupsBatchCreateEventGroups,
  )

  return axiosQuery<ListEventGroupsResponseInput>(
    {
      url: `/event-groups/batch-create-or-read`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: bodyEventGroupsBatchCreateEventGroups,
    },
    options,
  )
}

export function getEventGroupsBatchCreateEventGroupsMutationOptions<
  TError = void | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof eventGroupsBatchCreateEventGroups>>,
    TError,
    { data: BodyEventGroupsBatchCreateEventGroups },
    TContext
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseMutationOptions<
    Awaited<ReturnType<typeof eventGroupsBatchCreateEventGroups>>,
    TError,
    { data: BodyEventGroupsBatchCreateEventGroups },
    TContext
  > {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof eventGroupsBatchCreateEventGroups>>,
    { data: BodyEventGroupsBatchCreateEventGroups }
  > = (props) => {
    const { data } = props ?? {}

    return eventGroupsBatchCreateEventGroups(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type EventGroupsBatchCreateEventGroupsMutationResult = NonNullable<
  Awaited<ReturnType<typeof eventGroupsBatchCreateEventGroups>>
>
export type EventGroupsBatchCreateEventGroupsMutationBody =
  BodyEventGroupsBatchCreateEventGroups
export type EventGroupsBatchCreateEventGroupsMutationError =
  void | HTTPValidationError

/**
 * @summary Batch Create Event Groups
 */
export function useEventGroupsBatchCreateEventGroups<
  TError = void | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof eventGroupsBatchCreateEventGroups>>,
    TError,
    { data: BodyEventGroupsBatchCreateEventGroups },
    TContext
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseMutationReturnType<
    Awaited<ReturnType<typeof eventGroupsBatchCreateEventGroups>>,
    TError,
    { data: BodyEventGroupsBatchCreateEventGroups },
    TContext
  > {
  const mutationOptions
    = getEventGroupsBatchCreateEventGroupsMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Update Event Group
 */
export function eventGroupsUpdateEventGroup(
  eventGroupId: MaybeRef<number>,
  updateEventGroup: MaybeRef<UpdateEventGroup>,
  options?: SecondParameter<typeof axiosQuery>,
) {
  eventGroupId = unref(eventGroupId)
  updateEventGroup = unref(updateEventGroup)

  return axiosQuery<ViewEventGroup>(
    {
      url: `/event-groups/${eventGroupId}`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: updateEventGroup,
    },
    options,
  )
}

export function getEventGroupsUpdateEventGroupMutationOptions<
  TError = void | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof eventGroupsUpdateEventGroup>>,
    TError,
    { eventGroupId: number, data: UpdateEventGroup },
    TContext
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseMutationOptions<
    Awaited<ReturnType<typeof eventGroupsUpdateEventGroup>>,
    TError,
    { eventGroupId: number, data: UpdateEventGroup },
    TContext
  > {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof eventGroupsUpdateEventGroup>>,
    { eventGroupId: number, data: UpdateEventGroup }
  > = (props) => {
    const { eventGroupId, data } = props ?? {}

    return eventGroupsUpdateEventGroup(eventGroupId, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type EventGroupsUpdateEventGroupMutationResult = NonNullable<
  Awaited<ReturnType<typeof eventGroupsUpdateEventGroup>>
>
export type EventGroupsUpdateEventGroupMutationBody = UpdateEventGroup
export type EventGroupsUpdateEventGroupMutationError =
  void | HTTPValidationError

/**
 * @summary Update Event Group
 */
export function useEventGroupsUpdateEventGroup<
  TError = void | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof eventGroupsUpdateEventGroup>>,
    TError,
    { eventGroupId: number, data: UpdateEventGroup },
    TContext
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseMutationReturnType<
    Awaited<ReturnType<typeof eventGroupsUpdateEventGroup>>,
    TError,
    { eventGroupId: number, data: UpdateEventGroup },
    TContext
  > {
  const mutationOptions
    = getEventGroupsUpdateEventGroupMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Get event group info by id
 * @summary Get Event Group
 */
export function eventGroupsGetEventGroup(
  eventGroupId: MaybeRef<number>,
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) {
  eventGroupId = unref(eventGroupId)

  return axiosQuery<ViewEventGroup>(
    { url: `/event-groups/${eventGroupId}`, method: 'GET', signal },
    options,
  )
}

export function useEventGroupsGetEventGroupQueryOptions<
  TData = Awaited<ReturnType<typeof eventGroupsGetEventGroup>>,
  TError = void | HTTPValidationError,
>(
  eventGroupId: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof eventGroupsGetEventGroup>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosQuery>
  },
) {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryKeyMutator(
    { eventGroupId },
    { url: `/event-groups/${eventGroupId}`, queryOptions },
  )

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof eventGroupsGetEventGroup>>
  > = ({ signal }) =>
    eventGroupsGetEventGroup(eventGroupId, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(eventGroupId)),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof eventGroupsGetEventGroup>>,
    TError,
    TData
  >
}

export type EventGroupsGetEventGroupQueryResult = NonNullable<
  Awaited<ReturnType<typeof eventGroupsGetEventGroup>>
>
export type EventGroupsGetEventGroupQueryError = void | HTTPValidationError

/**
 * @summary Get Event Group
 */
export function useEventGroupsGetEventGroup<
  TData = Awaited<ReturnType<typeof eventGroupsGetEventGroup>>,
  TError = void | HTTPValidationError,
>(
  eventGroupId: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof eventGroupsGetEventGroup>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosQuery>
  },
): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = useEventGroupsGetEventGroupQueryOptions(
    eventGroupId,
    options,
  )

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = unref(queryOptions).queryKey as QueryKey

  return query
}

/**
 * Get event group info by path
 * @summary Find Event Group By Path
 */
export function eventGroupsFindEventGroupByPath(
  params: MaybeRef<EventGroupsFindEventGroupByPathParams>,
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) {
  params = unref(params)

  return axiosQuery<ViewEventGroup>(
    {
      url: `/event-groups/by-path`,
      method: 'GET',
      params: unref(params),
      signal,
    },
    options,
  )
}

export function useEventGroupsFindEventGroupByPathQueryOptions<
  TData = Awaited<ReturnType<typeof eventGroupsFindEventGroupByPath>>,
  TError = void | HTTPValidationError,
>(
  params: MaybeRef<EventGroupsFindEventGroupByPathParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof eventGroupsFindEventGroupByPath>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosQuery>
  },
) {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryKeyMutator(
    { params },
    { url: `/event-groups/by-path`, queryOptions },
  )

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof eventGroupsFindEventGroupByPath>>
  > = ({ signal }) =>
    eventGroupsFindEventGroupByPath(params, requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof eventGroupsFindEventGroupByPath>>,
    TError,
    TData
  >
}

export type EventGroupsFindEventGroupByPathQueryResult = NonNullable<
  Awaited<ReturnType<typeof eventGroupsFindEventGroupByPath>>
>
export type EventGroupsFindEventGroupByPathQueryError =
  void | HTTPValidationError

/**
 * @summary Find Event Group By Path
 */
export function useEventGroupsFindEventGroupByPath<
  TData = Awaited<ReturnType<typeof eventGroupsFindEventGroupByPath>>,
  TError = void | HTTPValidationError,
>(
  params: MaybeRef<EventGroupsFindEventGroupByPathParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof eventGroupsFindEventGroupByPath>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosQuery>
  },
): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = useEventGroupsFindEventGroupByPathQueryOptions(
    params,
    options,
  )

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = unref(queryOptions).queryKey as QueryKey

  return query
}

/**
 * Get event group info by alias
 * @summary Find Event Group By Alias
 */
export function eventGroupsFindEventGroupByAlias(
  params: MaybeRef<EventGroupsFindEventGroupByAliasParams>,
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) {
  params = unref(params)

  return axiosQuery<ViewEventGroup>(
    {
      url: `/event-groups/by-alias`,
      method: 'GET',
      params: unref(params),
      signal,
    },
    options,
  )
}

export function useEventGroupsFindEventGroupByAliasQueryOptions<
  TData = Awaited<ReturnType<typeof eventGroupsFindEventGroupByAlias>>,
  TError = void | HTTPValidationError,
>(
  params: MaybeRef<EventGroupsFindEventGroupByAliasParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof eventGroupsFindEventGroupByAlias>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosQuery>
  },
) {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryKeyMutator(
    { params },
    { url: `/event-groups/by-alias`, queryOptions },
  )

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof eventGroupsFindEventGroupByAlias>>
  > = ({ signal }) =>
    eventGroupsFindEventGroupByAlias(params, requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof eventGroupsFindEventGroupByAlias>>,
    TError,
    TData
  >
}

export type EventGroupsFindEventGroupByAliasQueryResult = NonNullable<
  Awaited<ReturnType<typeof eventGroupsFindEventGroupByAlias>>
>
export type EventGroupsFindEventGroupByAliasQueryError =
  void | HTTPValidationError

/**
 * @summary Find Event Group By Alias
 */
export function useEventGroupsFindEventGroupByAlias<
  TData = Awaited<ReturnType<typeof eventGroupsFindEventGroupByAlias>>,
  TError = void | HTTPValidationError,
>(
  params: MaybeRef<EventGroupsFindEventGroupByAliasParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof eventGroupsFindEventGroupByAlias>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosQuery>
  },
): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = useEventGroupsFindEventGroupByAliasQueryOptions(
    params,
    options,
  )

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = unref(queryOptions).queryKey as QueryKey

  return query
}

/**
 * Delete event group by alias
 * @summary Delete Event Group By Alias
 */
export function eventGroupsDeleteEventGroupByAlias(
  params: MaybeRef<EventGroupsDeleteEventGroupByAliasParams>,
  options?: SecondParameter<typeof axiosQuery>,
) {
  params = unref(params)

  return axiosQuery<unknown>(
    { url: `/event-groups/by-alias`, method: 'DELETE', params: unref(params) },
    options,
  )
}

export function getEventGroupsDeleteEventGroupByAliasMutationOptions<
  TError = void | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof eventGroupsDeleteEventGroupByAlias>>,
    TError,
    { params: EventGroupsDeleteEventGroupByAliasParams },
    TContext
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseMutationOptions<
    Awaited<ReturnType<typeof eventGroupsDeleteEventGroupByAlias>>,
    TError,
    { params: EventGroupsDeleteEventGroupByAliasParams },
    TContext
  > {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof eventGroupsDeleteEventGroupByAlias>>,
    { params: EventGroupsDeleteEventGroupByAliasParams }
  > = (props) => {
    const { params } = props ?? {}

    return eventGroupsDeleteEventGroupByAlias(params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type EventGroupsDeleteEventGroupByAliasMutationResult = NonNullable<
  Awaited<ReturnType<typeof eventGroupsDeleteEventGroupByAlias>>
>

export type EventGroupsDeleteEventGroupByAliasMutationError =
  void | HTTPValidationError

/**
 * @summary Delete Event Group By Alias
 */
export function useEventGroupsDeleteEventGroupByAlias<
  TError = void | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof eventGroupsDeleteEventGroupByAlias>>,
    TError,
    { params: EventGroupsDeleteEventGroupByAliasParams },
    TContext
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseMutationReturnType<
    Awaited<ReturnType<typeof eventGroupsDeleteEventGroupByAlias>>,
    TError,
    { params: EventGroupsDeleteEventGroupByAliasParams },
    TContext
  > {
  const mutationOptions
    = getEventGroupsDeleteEventGroupByAliasMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Load .ics file to event group by event group id and save file to predefined path
 * @summary Set Event Group Ics
 */
export function eventGroupsSetEventGroupIcs(
  eventGroupId: MaybeRef<number>,
  bodyEventGroupsSetEventGroupIcs: MaybeRef<BodyEventGroupsSetEventGroupIcs>,
  options?: SecondParameter<typeof axiosQuery>,
) {
  eventGroupId = unref(eventGroupId)
  bodyEventGroupsSetEventGroupIcs = unref(bodyEventGroupsSetEventGroupIcs)
  const formData = new FormData()
  formData.append('ics_file', bodyEventGroupsSetEventGroupIcs.ics_file)

  return axiosQuery<void | unknown>(
    {
      url: `/event-groups/${eventGroupId}/schedule.ics`,
      method: 'PUT',
      headers: { 'Content-Type': 'multipart/form-data' },
      data: formData,
    },
    options,
  )
}

export function getEventGroupsSetEventGroupIcsMutationOptions<
  TError = void | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof eventGroupsSetEventGroupIcs>>,
    TError,
    { eventGroupId: number, data: BodyEventGroupsSetEventGroupIcs },
    TContext
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseMutationOptions<
    Awaited<ReturnType<typeof eventGroupsSetEventGroupIcs>>,
    TError,
    { eventGroupId: number, data: BodyEventGroupsSetEventGroupIcs },
    TContext
  > {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof eventGroupsSetEventGroupIcs>>,
    { eventGroupId: number, data: BodyEventGroupsSetEventGroupIcs }
  > = (props) => {
    const { eventGroupId, data } = props ?? {}

    return eventGroupsSetEventGroupIcs(eventGroupId, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type EventGroupsSetEventGroupIcsMutationResult = NonNullable<
  Awaited<ReturnType<typeof eventGroupsSetEventGroupIcs>>
>
export type EventGroupsSetEventGroupIcsMutationBody =
  BodyEventGroupsSetEventGroupIcs
export type EventGroupsSetEventGroupIcsMutationError =
  void | HTTPValidationError

/**
 * @summary Set Event Group Ics
 */
export function useEventGroupsSetEventGroupIcs<
  TError = void | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof eventGroupsSetEventGroupIcs>>,
    TError,
    { eventGroupId: number, data: BodyEventGroupsSetEventGroupIcs },
    TContext
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseMutationReturnType<
    Awaited<ReturnType<typeof eventGroupsSetEventGroupIcs>>,
    TError,
    { eventGroupId: number, data: BodyEventGroupsSetEventGroupIcs },
    TContext
  > {
  const mutationOptions
    = getEventGroupsSetEventGroupIcsMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Get a list of all tags
 * @summary List Tags
 */
export function tagsListTags(
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) {
  return axiosQuery<ListTagsResponse>(
    { url: `/tags/`, method: 'GET', signal },
    options,
  )
}

export function useTagsListTagsQueryOptions<
  TData = Awaited<ReturnType<typeof tagsListTags>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof tagsListTags>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosQuery>
}) {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryKeyMutator({}, { url: `/tags/`, queryOptions })

  const queryFn: QueryFunction<Awaited<ReturnType<typeof tagsListTags>>> = ({
    signal,
  }) => tagsListTags(requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof tagsListTags>>,
    TError,
    TData
  >
}

export type TagsListTagsQueryResult = NonNullable<
  Awaited<ReturnType<typeof tagsListTags>>
>
export type TagsListTagsQueryError = unknown

/**
 * @summary List Tags
 */
export function useTagsListTags<
  TData = Awaited<ReturnType<typeof tagsListTags>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof tagsListTags>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = useTagsListTagsQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = unref(queryOptions).queryKey as QueryKey

  return query
}

/**
 * Create tags in batch
 * @summary Batch Create Tags
 */
export function tagsBatchCreateTags(
  bodyTagsBatchCreateTags: MaybeRef<BodyTagsBatchCreateTags>,
  options?: SecondParameter<typeof axiosQuery>,
) {
  bodyTagsBatchCreateTags = unref(bodyTagsBatchCreateTags)

  return axiosQuery<ListTagsResponse>(
    {
      url: `/tags/batch-create-or-read`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: bodyTagsBatchCreateTags,
    },
    options,
  )
}

export function getTagsBatchCreateTagsMutationOptions<
  TError = void | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof tagsBatchCreateTags>>,
    TError,
    { data: BodyTagsBatchCreateTags },
    TContext
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseMutationOptions<
    Awaited<ReturnType<typeof tagsBatchCreateTags>>,
    TError,
    { data: BodyTagsBatchCreateTags },
    TContext
  > {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof tagsBatchCreateTags>>,
    { data: BodyTagsBatchCreateTags }
  > = (props) => {
    const { data } = props ?? {}

    return tagsBatchCreateTags(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type TagsBatchCreateTagsMutationResult = NonNullable<
  Awaited<ReturnType<typeof tagsBatchCreateTags>>
>
export type TagsBatchCreateTagsMutationBody = BodyTagsBatchCreateTags
export type TagsBatchCreateTagsMutationError = void | HTTPValidationError

/**
 * @summary Batch Create Tags
 */
export function useTagsBatchCreateTags<
  TError = void | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof tagsBatchCreateTags>>,
    TError,
    { data: BodyTagsBatchCreateTags },
    TContext
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseMutationReturnType<
    Awaited<ReturnType<typeof tagsBatchCreateTags>>,
    TError,
    { data: BodyTagsBatchCreateTags },
    TContext
  > {
  const mutationOptions = getTagsBatchCreateTagsMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Get schedule in ICS format for the current user
 * @summary Get Current User Schedule
 */
export function icsGetCurrentUserSchedule(
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) {
  return axiosQuery<unknown | Blob>(
    { url: `/users/me/all.ics`, method: 'GET', signal },
    options,
  )
}

export function useIcsGetCurrentUserScheduleQueryOptions<
  TData = Awaited<ReturnType<typeof icsGetCurrentUserSchedule>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof icsGetCurrentUserSchedule>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosQuery>
}) {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryKeyMutator(
    {},
    { url: `/users/me/all.ics`, queryOptions },
  )

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof icsGetCurrentUserSchedule>>
  > = ({ signal }) => icsGetCurrentUserSchedule(requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof icsGetCurrentUserSchedule>>,
    TError,
    TData
  >
}

export type IcsGetCurrentUserScheduleQueryResult = NonNullable<
  Awaited<ReturnType<typeof icsGetCurrentUserSchedule>>
>
export type IcsGetCurrentUserScheduleQueryError = unknown

/**
 * @summary Get Current User Schedule
 */
export function useIcsGetCurrentUserSchedule<
  TData = Awaited<ReturnType<typeof icsGetCurrentUserSchedule>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof icsGetCurrentUserSchedule>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = useIcsGetCurrentUserScheduleQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = unref(queryOptions).queryKey as QueryKey

  return query
}

/**
 * Get schedule in ICS format for the user; requires access key for `/users/{user_id}/all.ics` resource
 * @summary Get User Schedule
 */
export function icsGetUserSchedule(
  userId: MaybeRef<number>,
  params: MaybeRef<IcsGetUserScheduleParams>,
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) {
  userId = unref(userId)
  params = unref(params)

  return axiosQuery<unknown | Blob>(
    {
      url: `/users/${userId}/all.ics`,
      method: 'GET',
      params: unref(params),
      signal,
    },
    options,
  )
}

export function useIcsGetUserScheduleQueryOptions<
  TData = Awaited<ReturnType<typeof icsGetUserSchedule>>,
  TError = void | HTTPValidationError,
>(
  userId: MaybeRef<number>,
  params: MaybeRef<IcsGetUserScheduleParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof icsGetUserSchedule>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosQuery>
  },
) {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryKeyMutator(
    { userId, params },
    { url: `/users/${userId}/all.ics`, queryOptions },
  )

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof icsGetUserSchedule>>
  > = ({ signal }) =>
    icsGetUserSchedule(userId, params, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(userId)),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof icsGetUserSchedule>>,
    TError,
    TData
  >
}

export type IcsGetUserScheduleQueryResult = NonNullable<
  Awaited<ReturnType<typeof icsGetUserSchedule>>
>
export type IcsGetUserScheduleQueryError = void | HTTPValidationError

/**
 * @summary Get User Schedule
 */
export function useIcsGetUserSchedule<
  TData = Awaited<ReturnType<typeof icsGetUserSchedule>>,
  TError = void | HTTPValidationError,
>(
  userId: MaybeRef<number>,
  params: MaybeRef<IcsGetUserScheduleParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof icsGetUserSchedule>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosQuery>
  },
): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = useIcsGetUserScheduleQueryOptions(
    userId,
    params,
    options,
  )

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = unref(queryOptions).queryKey as QueryKey

  return query
}

/**
 * Get schedule in ICS format for the current user
 * @summary Get Music Room Current User Schedule
 */
export function icsGetMusicRoomCurrentUserSchedule(
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) {
  return axiosQuery<unknown | Blob>(
    { url: `/users/me/music-room.ics`, method: 'GET', signal },
    options,
  )
}

export function useIcsGetMusicRoomCurrentUserScheduleQueryOptions<
  TData = Awaited<ReturnType<typeof icsGetMusicRoomCurrentUserSchedule>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof icsGetMusicRoomCurrentUserSchedule>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosQuery>
}) {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryKeyMutator(
    {},
    { url: `/users/me/music-room.ics`, queryOptions },
  )

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof icsGetMusicRoomCurrentUserSchedule>>
  > = ({ signal }) =>
    icsGetMusicRoomCurrentUserSchedule(requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof icsGetMusicRoomCurrentUserSchedule>>,
    TError,
    TData
  >
}

export type IcsGetMusicRoomCurrentUserScheduleQueryResult = NonNullable<
  Awaited<ReturnType<typeof icsGetMusicRoomCurrentUserSchedule>>
>
export type IcsGetMusicRoomCurrentUserScheduleQueryError = unknown

/**
 * @summary Get Music Room Current User Schedule
 */
export function useIcsGetMusicRoomCurrentUserSchedule<
  TData = Awaited<ReturnType<typeof icsGetMusicRoomCurrentUserSchedule>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof icsGetMusicRoomCurrentUserSchedule>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } {
  const queryOptions
    = useIcsGetMusicRoomCurrentUserScheduleQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = unref(queryOptions).queryKey as QueryKey

  return query
}

/**
 * Get schedule in ICS format for the user; requires access key for `/users/{user_id}/music-room.ics` resource
 * @summary Get Music Room User Schedule
 */
export function icsGetMusicRoomUserSchedule(
  userId: MaybeRef<number>,
  params: MaybeRef<IcsGetMusicRoomUserScheduleParams>,
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) {
  userId = unref(userId)
  params = unref(params)

  return axiosQuery<unknown | Blob>(
    {
      url: `/users/${userId}/music-room.ics`,
      method: 'GET',
      params: unref(params),
      signal,
    },
    options,
  )
}

export function useIcsGetMusicRoomUserScheduleQueryOptions<
  TData = Awaited<ReturnType<typeof icsGetMusicRoomUserSchedule>>,
  TError = void | HTTPValidationError,
>(
  userId: MaybeRef<number>,
  params: MaybeRef<IcsGetMusicRoomUserScheduleParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof icsGetMusicRoomUserSchedule>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosQuery>
  },
) {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryKeyMutator(
    { userId, params },
    { url: `/users/${userId}/music-room.ics`, queryOptions },
  )

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof icsGetMusicRoomUserSchedule>>
  > = ({ signal }) =>
    icsGetMusicRoomUserSchedule(userId, params, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(userId)),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof icsGetMusicRoomUserSchedule>>,
    TError,
    TData
  >
}

export type IcsGetMusicRoomUserScheduleQueryResult = NonNullable<
  Awaited<ReturnType<typeof icsGetMusicRoomUserSchedule>>
>
export type IcsGetMusicRoomUserScheduleQueryError = void | HTTPValidationError

/**
 * @summary Get Music Room User Schedule
 */
export function useIcsGetMusicRoomUserSchedule<
  TData = Awaited<ReturnType<typeof icsGetMusicRoomUserSchedule>>,
  TError = void | HTTPValidationError,
>(
  userId: MaybeRef<number>,
  params: MaybeRef<IcsGetMusicRoomUserScheduleParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof icsGetMusicRoomUserSchedule>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosQuery>
  },
): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = useIcsGetMusicRoomUserScheduleQueryOptions(
    userId,
    params,
    options,
  )

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = unref(queryOptions).queryKey as QueryKey

  return query
}

/**
 * Get schedule in ICS format for the current user
 * @summary Get Sport Current User Schedule
 */
export function icsGetSportCurrentUserSchedule(
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) {
  return axiosQuery<unknown | Blob>(
    { url: `/users/me/sport.ics`, method: 'GET', signal },
    options,
  )
}

export function useIcsGetSportCurrentUserScheduleQueryOptions<
  TData = Awaited<ReturnType<typeof icsGetSportCurrentUserSchedule>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof icsGetSportCurrentUserSchedule>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosQuery>
}) {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryKeyMutator(
    {},
    { url: `/users/me/sport.ics`, queryOptions },
  )

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof icsGetSportCurrentUserSchedule>>
  > = ({ signal }) => icsGetSportCurrentUserSchedule(requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof icsGetSportCurrentUserSchedule>>,
    TError,
    TData
  >
}

export type IcsGetSportCurrentUserScheduleQueryResult = NonNullable<
  Awaited<ReturnType<typeof icsGetSportCurrentUserSchedule>>
>
export type IcsGetSportCurrentUserScheduleQueryError = unknown

/**
 * @summary Get Sport Current User Schedule
 */
export function useIcsGetSportCurrentUserSchedule<
  TData = Awaited<ReturnType<typeof icsGetSportCurrentUserSchedule>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof icsGetSportCurrentUserSchedule>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = useIcsGetSportCurrentUserScheduleQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = unref(queryOptions).queryKey as QueryKey

  return query
}

/**
 * Get schedule in ICS format for the user; requires access key for `/users/{user_id}/sport.ics` resource
 * @summary Get Sport User Schedule
 */
export function icsGetSportUserSchedule(
  userId: MaybeRef<number>,
  params: MaybeRef<IcsGetSportUserScheduleParams>,
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) {
  userId = unref(userId)
  params = unref(params)

  return axiosQuery<unknown | Blob>(
    {
      url: `/users/${userId}/sport.ics`,
      method: 'GET',
      params: unref(params),
      signal,
    },
    options,
  )
}

export function useIcsGetSportUserScheduleQueryOptions<
  TData = Awaited<ReturnType<typeof icsGetSportUserSchedule>>,
  TError = void | HTTPValidationError,
>(
  userId: MaybeRef<number>,
  params: MaybeRef<IcsGetSportUserScheduleParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof icsGetSportUserSchedule>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosQuery>
  },
) {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryKeyMutator(
    { userId, params },
    { url: `/users/${userId}/sport.ics`, queryOptions },
  )

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof icsGetSportUserSchedule>>
  > = ({ signal }) =>
    icsGetSportUserSchedule(userId, params, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(userId)),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof icsGetSportUserSchedule>>,
    TError,
    TData
  >
}

export type IcsGetSportUserScheduleQueryResult = NonNullable<
  Awaited<ReturnType<typeof icsGetSportUserSchedule>>
>
export type IcsGetSportUserScheduleQueryError = void | HTTPValidationError

/**
 * @summary Get Sport User Schedule
 */
export function useIcsGetSportUserSchedule<
  TData = Awaited<ReturnType<typeof icsGetSportUserSchedule>>,
  TError = void | HTTPValidationError,
>(
  userId: MaybeRef<number>,
  params: MaybeRef<IcsGetSportUserScheduleParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof icsGetSportUserSchedule>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosQuery>
  },
): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = useIcsGetSportUserScheduleQueryOptions(
    userId,
    params,
    options,
  )

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = unref(queryOptions).queryKey as QueryKey

  return query
}

/**
 * Get schedule in ICS format for the user
 * @summary Get User Linked Schedule
 */
export function icsGetUserLinkedSchedule(
  userId: MaybeRef<number>,
  linkedAlias: MaybeRef<string>,
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) {
  userId = unref(userId)
  linkedAlias = unref(linkedAlias)

  return axiosQuery<unknown | Blob>(
    {
      url: `/users/${userId}/linked/${linkedAlias}.ics`,
      method: 'GET',
      signal,
    },
    options,
  )
}

export function useIcsGetUserLinkedScheduleQueryOptions<
  TData = Awaited<ReturnType<typeof icsGetUserLinkedSchedule>>,
  TError = void | HTTPValidationError,
>(
  userId: MaybeRef<number>,
  linkedAlias: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof icsGetUserLinkedSchedule>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosQuery>
  },
) {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryKeyMutator(
    { userId, linkedAlias },
    { url: `/users/${userId}/linked/${linkedAlias}.ics`, queryOptions },
  )

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof icsGetUserLinkedSchedule>>
  > = ({ signal }) =>
    icsGetUserLinkedSchedule(userId, linkedAlias, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!(unref(userId) && unref(linkedAlias))),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof icsGetUserLinkedSchedule>>,
    TError,
    TData
  >
}

export type IcsGetUserLinkedScheduleQueryResult = NonNullable<
  Awaited<ReturnType<typeof icsGetUserLinkedSchedule>>
>
export type IcsGetUserLinkedScheduleQueryError = void | HTTPValidationError

/**
 * @summary Get User Linked Schedule
 */
export function useIcsGetUserLinkedSchedule<
  TData = Awaited<ReturnType<typeof icsGetUserLinkedSchedule>>,
  TError = void | HTTPValidationError,
>(
  userId: MaybeRef<number>,
  linkedAlias: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof icsGetUserLinkedSchedule>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosQuery>
  },
): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = useIcsGetUserLinkedScheduleQueryOptions(
    userId,
    linkedAlias,
    options,
  )

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = unref(queryOptions).queryKey as QueryKey

  return query
}

/**
 * Get schedule in ICS format for the music room
 * @summary Get Music Room Schedule
 */
export function icsGetMusicRoomSchedule(
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) {
  return axiosQuery<Blob>(
    { url: `/music-room.ics`, method: 'GET', responseType: 'blob', signal },
    options,
  )
}

export function useIcsGetMusicRoomScheduleQueryOptions<
  TData = Awaited<ReturnType<typeof icsGetMusicRoomSchedule>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof icsGetMusicRoomSchedule>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosQuery>
}) {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryKeyMutator(
    {},
    { url: `/music-room.ics`, queryOptions },
  )

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof icsGetMusicRoomSchedule>>
  > = ({ signal }) => icsGetMusicRoomSchedule(requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof icsGetMusicRoomSchedule>>,
    TError,
    TData
  >
}

export type IcsGetMusicRoomScheduleQueryResult = NonNullable<
  Awaited<ReturnType<typeof icsGetMusicRoomSchedule>>
>
export type IcsGetMusicRoomScheduleQueryError = unknown

/**
 * @summary Get Music Room Schedule
 */
export function useIcsGetMusicRoomSchedule<
  TData = Awaited<ReturnType<typeof icsGetMusicRoomSchedule>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof icsGetMusicRoomSchedule>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = useIcsGetMusicRoomScheduleQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = unref(queryOptions).queryKey as QueryKey

  return query
}

/**
 * Get event group .ics file by id
 * @summary Get Event Group Ics By Alias
 */
export function icsGetEventGroupIcsByAlias(
  eventGroupAlias: MaybeRef<string>,
  params: MaybeRef<IcsGetEventGroupIcsByAliasParams>,
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) {
  eventGroupAlias = unref(eventGroupAlias)
  params = unref(params)

  return axiosQuery<Blob>(
    {
      url: `/${eventGroupAlias}.ics`,
      method: 'GET',
      params: unref(params),
      responseType: 'blob',
      signal,
    },
    options,
  )
}

export function useIcsGetEventGroupIcsByAliasQueryOptions<
  TData = Awaited<ReturnType<typeof icsGetEventGroupIcsByAlias>>,
  TError = void | HTTPValidationError,
>(
  eventGroupAlias: MaybeRef<string>,
  params: MaybeRef<IcsGetEventGroupIcsByAliasParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof icsGetEventGroupIcsByAlias>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosQuery>
  },
) {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryKeyMutator(
    { eventGroupAlias, params },
    { url: `/${eventGroupAlias}.ics`, queryOptions },
  )

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof icsGetEventGroupIcsByAlias>>
  > = ({ signal }) =>
    icsGetEventGroupIcsByAlias(eventGroupAlias, params, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(eventGroupAlias)),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof icsGetEventGroupIcsByAlias>>,
    TError,
    TData
  >
}

export type IcsGetEventGroupIcsByAliasQueryResult = NonNullable<
  Awaited<ReturnType<typeof icsGetEventGroupIcsByAlias>>
>
export type IcsGetEventGroupIcsByAliasQueryError = void | HTTPValidationError

/**
 * @summary Get Event Group Ics By Alias
 */
export function useIcsGetEventGroupIcsByAlias<
  TData = Awaited<ReturnType<typeof icsGetEventGroupIcsByAlias>>,
  TError = void | HTTPValidationError,
>(
  eventGroupAlias: MaybeRef<string>,
  params: MaybeRef<IcsGetEventGroupIcsByAliasParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof icsGetEventGroupIcsByAlias>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosQuery>
  },
): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = useIcsGetEventGroupIcsByAliasQueryOptions(
    eventGroupAlias,
    params,
    options,
  )

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = unref(queryOptions).queryKey as QueryKey

  return query
}

/**
 * Endpoint that serves Prometheus metrics.
 * @summary Metrics
 */
export function metrics(
  options?: SecondParameter<typeof axiosQuery>,
  signal?: AbortSignal,
) {
  return axiosQuery<unknown>(
    { url: `/metrics`, method: 'GET', signal },
    options,
  )
}

export function useMetricsQueryOptions<
  TData = Awaited<ReturnType<typeof metrics>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof metrics>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosQuery>
}) {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryKeyMutator({}, { url: `/metrics`, queryOptions })

  const queryFn: QueryFunction<Awaited<ReturnType<typeof metrics>>> = ({
    signal,
  }) => metrics(requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof metrics>>,
    TError,
    TData
  >
}

export type MetricsQueryResult = NonNullable<
  Awaited<ReturnType<typeof metrics>>
>
export type MetricsQueryError = unknown

/**
 * @summary Metrics
 */
export function useMetrics<
  TData = Awaited<ReturnType<typeof metrics>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof metrics>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosQuery>
}): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = useMetricsQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = unref(queryOptions).queryKey as QueryKey

  return query
}
